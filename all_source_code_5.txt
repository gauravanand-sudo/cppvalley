=== FILE: src/app/learn/tracks/[trackSlug]/[lessonSlug]/page.tsx ===
// src/app/learn/tracks/[trackSlug]/[lessonSlug]/page.tsx
import { notFound } from "next/navigation";
import MdxRenderer from "@/components/MdxRenderer";
import { requireContent, parseTrackSyllabus } from "@/lib/content";
import { getUserEntitlements, canAccessTrack } from "@/lib/entitlements";

type AnyItem = { title: string; slug?: string; children?: AnyItem[] };

function flatten(items: AnyItem[], out: AnyItem[] = []) {
  for (const it of items) {
    if (it?.slug) out.push(it);
    if (Array.isArray(it?.children)) flatten(it.children, out);
  }
  return out;
}

function loadLesson(trackSlug: string, lessonSlug: string) {
  // 1) preferred: per-track folder
  try {
    return requireContent("learn", `${trackSlug}/${lessonSlug}`);
  } catch {}

  // 2) fallback: old flat folder (optional)
  try {
    return requireContent("learn", lessonSlug);
  } catch {}

  notFound();
}

export default async function TrackLessonPage(props: { params: any }) {
  const p = await props.params;
  const trackSlug = p?.trackSlug;
  const lessonSlug = p?.lessonSlug;

  if (typeof trackSlug !== "string" || typeof lessonSlug !== "string") {
    notFound();
  }

  // 1) Load track
  const track = requireContent("tracks", trackSlug);

  // 2) Ensure lesson exists in syllabus
  const sections = parseTrackSyllabus(track.content);
  const all = flatten(sections.flatMap((s: any) => s.items ?? []));
  const idx = all.findIndex((x) => x.slug === lessonSlug);
  if (idx === -1) notFound();

  // 3) Load lesson content (NOW: per-track folder)
  const { meta, content } = loadLesson(trackSlug, lessonSlug);

  // 4) Entitlements
  const entitlements = await getUserEntitlements();
  const hasTrackAccess = canAccessTrack(entitlements, trackSlug);

  // 5) Lock logic
  const locked =
    (meta.access === "premium" || meta.access === "paid") && !hasTrackAccess;

  return (
    <div>
      <div className="deepseek-prose max-w-none">
        <h1 className="text-3xl font-bold text-gray-900 mb-4">{meta.title}</h1>
        {meta.description && (
          <p className="text-lg text-gray-600 mb-6 leading-relaxed">
            {meta.description}
          </p>
        )}

        <div className="mt-6">
          {locked ? (
            <div className="rounded-xl border border-gray-200 bg-gray-50 p-8">
              <div className="flex items-center gap-3 mb-4">
                <div className="w-10 h-10 rounded-full bg-blue-100 flex items-center justify-center">
                  <span className="text-blue-600 text-xl">üîí</span>
                </div>
                <div>
                  <p className="text-lg font-semibold text-gray-900">
                    Premium Lesson
                  </p>
                  <p className="text-sm text-gray-600 mt-1">
                    This lesson is part of the premium track
                  </p>
                </div>
              </div>

              <div className="mt-4">
                <div className="text-sm text-gray-500 mb-2">
                  Track:{" "}
                  <span className="font-mono text-blue-700 font-medium">
                    {trackSlug}
                  </span>
                </div>
              </div>

              <div className="mt-6 bg-white rounded-lg border border-gray-200 p-4">
                <div className="text-sm text-gray-500 mb-2">Preview</div>
                <div className="text-gray-700">
                  <MdxRenderer source={content.slice(0, 700)} />
                </div>
              </div>

              <div className="mt-8 pt-6 border-t border-gray-200">
                <p className="text-sm text-gray-600 mb-4">
                  Subscribe to unlock full access to this track and all premium
                  content
                </p>
                <div className="flex gap-3">
                  <a
                    href={`/checkout?track=${trackSlug}&plan=monthly`}
                    className="rounded-lg bg-blue-600 px-5 py-2.5 font-medium text-white hover:bg-blue-700 transition-colors"
                  >
                    Subscribe to this Track
                  </a>

                  <a
                    href="/pricing"
                    className="rounded-lg border border-gray-300 bg-white px-5 py-2.5 font-medium text-gray-700 hover:bg-gray-50 transition-colors"
                  >
                    View Pricing
                  </a>
                </div>
                <p className="mt-3 text-xs text-gray-500">
                  Cancel anytime. Full access to all lessons in this track.
                </p>
              </div>
            </div>
          ) : (
            <MdxRenderer source={content} />
          )}
        </div>
      </div>
    </div>
  );
}

=== FILE: src/app/learn/tracks/[trackSlug]/layout.tsx ===
// src/app/learn/tracks/[trackSlug]/layout.tsx
import { notFound } from "next/navigation";
import { requireContent, parseTrackSyllabus } from "@/lib/content";
import TrackLayout from "@/components/TrackLayout";
import TrackSidebar from "@/components/TrackSidebar";
import LessonContentWrapper from "@/components/LessonContentWrapper";

export default async function TrackLayoutPage({
  children,
  params,
}: {
  children: React.ReactNode;
  params: any;
}) {
  const p = await params;
  const trackSlug = p?.trackSlug;

  if (typeof trackSlug !== "string") notFound();

  const track = requireContent("tracks", trackSlug);
  const sections = parseTrackSyllabus(track.content);

  return (
    <TrackLayout
      sidebar={<TrackSidebar trackSlug={trackSlug} sections={sections} />}
    >
      <LessonContentWrapper trackSlug={trackSlug} sections={sections}>
        {children}
      </LessonContentWrapper>
    </TrackLayout>
  );
}

=== FILE: src/app/learn/tracks/[trackSlug]/page.tsx ===
import Link from "next/link";
import { notFound } from "next/navigation";
import {
  getTrackBySlug,
  parseTrackSyllabus,
  flattenTrackLessonSlugs,
} from "@/lib/content";
import { getProgress } from "@/lib/progress";
import { getUserEntitlements, canAccessTrack } from "@/lib/entitlements";
import SiteHeader from "@/components/SiteHeader";
import SiteFooter from "@/components/SiteFooter";

function Badge({ children }: { children: React.ReactNode }) {
  return (
    <span className="rounded-full border border-gray-200 bg-gray-50 px-3 py-1 text-xs font-mono text-gray-700">
      {children}
    </span>
  );
}

export default async function TrackOverviewPage({
  params,
}: {
  params: Promise<{ trackSlug: string }>;
}) {
  const { trackSlug } = await params;

  const track = getTrackBySlug(trackSlug);
  if (!track?.meta) notFound();

  const sections = parseTrackSyllabus(track.content);
  const ordered = flattenTrackLessonSlugs(sections);
  const firstLessonSlug = ordered[0];

  if (!firstLessonSlug) {
    return (
      <>
        <SiteHeader />
        <main className="mx-auto max-w-5xl px-6 py-12">
          <h1 className="text-3xl font-bold">{track.meta.title}</h1>
          <p className="mt-3 text-gray-600">No lessons found in this track syllabus.</p>
        </main>
        <SiteFooter />
      </>
    );
  }

  // DB progress (continue)
  const progress = await getProgress(trackSlug);
  const last = progress?.lastLessonSlug ?? null;
  const continueSlug = last && ordered.includes(last) ? last : firstLessonSlug;

  // entitlements
  const ent = await getUserEntitlements();
  const hasAccess = canAccessTrack(ent, trackSlug);

  return (
  

      <main className="relative bg-white text-gray-900">
        {/* abstract background */}
        <div className="pointer-events-none absolute inset-0">
          <div className="absolute -top-40 -left-40 h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
          <div className="absolute top-1/2 -right-40 h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
        </div>

        <div className="relative mx-auto max-w-5xl px-6 py-12">
          <div className="flex flex-wrap items-end justify-between gap-6">
            <div className="max-w-2xl">
              <h1 className="text-3xl font-bold tracking-tight">{track.meta.title}</h1>
              {track.meta.description && (
                <p className="mt-3 text-gray-600 leading-relaxed">{track.meta.description}</p>
              )}

              <div className="mt-4 flex flex-wrap gap-2">
                {track.meta.duration && <Badge>{track.meta.duration}</Badge>}
                {track.meta.level && <Badge>{track.meta.level}</Badge>}
                <Badge>lessons: {ordered.length}</Badge>
              </div>
            </div>

            <div className="flex flex-wrap gap-3">
              {hasAccess ? (
                <Link
                  href={`/learn/tracks/${trackSlug}/${continueSlug}`}
                  className="rounded-xl bg-cyan-600 px-4 py-2 text-sm font-semibold text-white hover:bg-cyan-700 transition"
                >
                  Continue
                </Link>
              ) : (
                <Link
                  href={`/pricing?track=${trackSlug}`}
                  className="rounded-xl bg-cyan-600 px-4 py-2 text-sm font-semibold text-white hover:bg-cyan-700 transition"
                >
                  Purchase this Track
                </Link>
              )}

              <Link
                href={`/learn/tracks/${trackSlug}/${firstLessonSlug}`}
                className="rounded-xl border border-gray-200 bg-white px-4 py-2 text-sm hover:bg-gray-50 transition"
              >
                Start from Day 1
              </Link>
            </div>
          </div>

          {/* syllabus card */}
          <div className="mt-10 rounded-2xl border border-gray-200 bg-white shadow-sm">
            <div className="border-b border-gray-200 px-6 py-4">
              <div className="text-sm font-mono text-gray-500">SYLLABUS</div>
              <div className="text-lg font-semibold text-gray-900">Inside this track</div>
            </div>

            <div className="px-6 py-6">
              <div className="grid gap-6">
                {sections.map((sec) => (
                  <div key={sec.title}>
                    <div className="text-xs font-mono uppercase tracking-wide text-gray-500">
                      {sec.title}
                    </div>

                    <div className="mt-3 grid gap-2">
                      {sec.items.map((it: any, idx) => {
                        if (it.children) {
                          return (
                            <div
                              key={`${sec.title}-${idx}`}
                              className="rounded-xl border border-gray-200 bg-gray-50/40 px-4 py-3"
                            >
                              <div className="font-semibold text-gray-900">
                                {it.title}
                              </div>

                              <div className="mt-2 grid gap-1">
                                {it.children.map((c: any) => (
                                  <Link
                                    key={c.slug}
                                    href={`/learn/tracks/${trackSlug}/${c.slug}`}
                                    className="rounded-lg px-2 py-1.5 text-sm text-gray-700 hover:bg-white hover:border hover:border-gray-200 transition"
                                  >
                                    {c.title}
                                  </Link>
                                ))}
                              </div>
                            </div>
                          );
                        }

                        return (
                          <Link
                            key={it.slug}
                            href={`/learn/tracks/${trackSlug}/${it.slug}`}
                            className="rounded-xl border border-gray-200 bg-white px-4 py-3 text-sm text-gray-800 hover:bg-gray-50 transition"
                          >
                            {it.title}
                          </Link>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>

          <div className="mt-12 border-t border-gray-200 pt-6 text-xs font-mono text-gray-400">
            cppvalley ¬∑ tracks ¬∑ systems-first
          </div>
        </div>
      </main>

   
  );
}

=== FILE: src/app/learn/tracks/page.tsx ===
import Link from "next/link";
import { listTracks } from "@/lib/content";
import { BookOpen, Clock, Target, Users, Zap, Cpu, Terminal, Calendar, Lock } from "lucide-react";
import SiteFooter from "@/components/SiteFooter";
import SiteHeader from "@/components/SiteHeader";
function AccentPill({
  children,
  tone,
}: {
  children: React.ReactNode;
  tone: "blue" | "green" | "amber" | "purple" | "gray";
}) {
  const toneClasses = {
    blue: "bg-blue-100 text-blue-800 border border-blue-200",
    green: "bg-green-100 text-green-800 border border-green-200",
    amber: "bg-amber-100 text-amber-800 border border-amber-200",
    purple: "bg-purple-100 text-purple-800 border border-purple-200",
    gray: "bg-gray-100 text-gray-800 border border-gray-200",
  };

  return (
    <span className={`inline-flex items-center rounded-full px-3 py-1 text-xs font-medium ${toneClasses[tone]}`}>
      {children}
    </span>
  );
}

function TrackIcon({ type }: { type: string }) {
  const icons = {
    "eda": <Cpu className="w-5 h-5" />,
    "hft": <Zap className="w-5 h-5" />,
    "systems": <Terminal className="w-5 h-5" />,
    "templates": <BookOpen className="w-5 h-5" />,
    "default": <Target className="w-5 h-5" />,
  };

  const iconType = type.toLowerCase().includes("eda") ? "eda" :
                   type.toLowerCase().includes("hft") ? "hft" :
                   type.toLowerCase().includes("system") ? "systems" :
                   type.toLowerCase().includes("template") ? "templates" : "default";
  
  return icons[iconType];
}

export default async function TracksPage() {
  const tracks = listTracks();
  
  // Debug log
  console.log('Total tracks found:', tracks.length);
  console.log('Track details:', tracks);

  // Get dynamic stats from tracks
  const totalLessons = tracks.reduce((sum, track) => sum + (track.lessonCount || 0), 0);
  const freeTracks = tracks.filter(t => t.access === "free").length;
  const premiumTracks = tracks.filter(t => t.access === "premium").length;
  const liveTracks = tracks.filter(t => t.live).length;
  const comingSoonTracks = tracks.filter(t => !t.live).length;

  return (
    <>
                  <SiteHeader />
    <div className="w-full max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      {/* Header */}
      <section className="mb-10">
        <div className="flex flex-col md:flex-row md:items-end justify-between gap-6">
          <div>
            <div className="flex items-center gap-3 mb-4">
              <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-blue-500 to-cyan-500 flex items-center justify-center">
                <BookOpen className="w-6 h-6 text-white" />
              </div>
              <div>
                <h1 className="text-3xl font-bold text-gray-900">Learning Tracks</h1>
                <p className="mt-1 text-gray-600 font-medium">
                  Master C++ Systems Engineering ‚Ä¢ Interview-First ‚Ä¢ Production Ready
                </p>
              </div>
            </div>
            
            <div className="flex flex-wrap gap-3 mt-4">
              <div className="flex items-center gap-2 text-sm text-gray-700 bg-gray-100 px-3 py-1.5 rounded-lg">
                <Users className="w-4 h-4" />
                <span>{tracks.length} Tracks</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-gray-700 bg-gray-100 px-3 py-1.5 rounded-lg">
                <BookOpen className="w-4 h-4" />
                <span>{totalLessons}+ Lessons</span>
              </div>
              <div className="flex items-center gap-2 text-sm text-gray-700 bg-gray-100 px-3 py-1.5 rounded-lg">
                <Clock className="w-4 h-4" />
                <span>{liveTracks} Live ‚Ä¢ {comingSoonTracks} Coming Soon</span>
              </div>
            </div>
          </div>

          <div className="flex flex-wrap gap-2">
            <AccentPill tone="green">{freeTracks} Free</AccentPill>
            <AccentPill tone="blue">{premiumTracks} Premium</AccentPill>
            <AccentPill tone="amber">{comingSoonTracks} Coming Soon</AccentPill>
          </div>
        </div>
      </section>

      {/* Description */}
      <section className="mb-10 p-6 bg-gradient-to-r from-blue-50 to-cyan-50 rounded-2xl border border-blue-100">
        <div className="max-w-3xl">
          <h2 className="text-xl font-semibold text-gray-900 mb-3">Structured Systems Mastery</h2>
          <p className="text-gray-700 leading-relaxed">
            Each track is a complete learning journey designed by industry experts. 
            From C++ object model fundamentals to advanced lock-free programming, 
            these tracks prepare you for elite interviews at EDA, HFT, and BigTech companies.
          </p>
          <div className="flex flex-wrap gap-3 mt-4">
            <span className="text-sm text-gray-600 bg-white px-3 py-1 rounded-lg border border-gray-200">
              <span className="font-semibold">ABI</span> as a contract
            </span>
            <span className="text-sm text-gray-600 bg-white px-3 py-1 rounded-lg border border-gray-200">
              <span className="font-semibold">p99</span> latency optimization
            </span>
            <span className="text-sm text-gray-600 bg-white px-3 py-1 rounded-lg border border-gray-200">
              <span className="font-semibold">Cache</span> ‚â† memory
            </span>
            <span className="text-sm text-gray-600 bg-white px-3 py-1 rounded-lg border border-gray-200">
              <span className="font-semibold">Concurrency</span> correctness
            </span>
          </div>
        </div>
      </section>

      {/* Tracks Grid */}
      <section className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
        {tracks.map((track) => {
          const isPremium = track.access === "premium";
          const isFree = track.access === "free";
          const isLive = track.live;
          
          if (!isLive) {
            return (
              <div
                key={track.slug}
                className="relative bg-white border border-gray-200 rounded-2xl p-6 opacity-80 cursor-not-allowed flex flex-col"
              >
                {/* Coming Soon Overlay */}
                <div className="absolute inset-0 bg-gradient-to-br from-gray-50/80 to-white/80 rounded-2xl" />
                
                <div className="relative flex-1 flex flex-col">
                  {/* Header */}
                  <div className="flex items-start gap-4 mb-4">
                    <div className="w-12 h-12 rounded-xl bg-gray-200 text-gray-500 flex items-center justify-center flex-shrink-0">
                      <TrackIcon type={track.title} />
                    </div>
                    
                    <div className="flex-1 min-w-0 pr-12">
                      <h2 className="text-lg font-bold text-gray-500 line-clamp-1">
                        {track.title}
                      </h2>
                      <div className="flex items-center gap-3 mt-1">
                        <div className="flex items-center gap-1 text-sm text-gray-500">
                          <Clock className="w-3 h-3 flex-shrink-0" />
                          <span>{track.duration || 'Coming Soon'}</span>
                        </div>
                        <div className="text-gray-400">‚Ä¢</div>
                        <div className="text-sm font-medium px-2 py-0.5 rounded bg-gray-200 text-gray-600">
                          {track.level || 'Advanced'}
                        </div>
                      </div>
                    </div>
                    
                    {/* Coming Soon Badge */}
                    <div className="absolute top-6 right-6">
                      <span className="inline-flex items-center gap-1 text-xs font-bold bg-gray-200 text-gray-700 px-2 py-1 rounded-full">
                        <Calendar className="w-3 h-3" />
                        COMING SOON
                      </span>
                    </div>
                  </div>

                  {/* Description */}
                  <div className="h-12 mb-4 flex-1">
                    {track.description ? (
                      <p className="text-gray-500 line-clamp-2 leading-relaxed">
                        {track.description}
                      </p>
                    ) : (
                      <p className="text-gray-400 italic">
                        Track details coming soon
                      </p>
                    )}
                  </div>

                  {/* Topics */}
                  <div className="flex flex-wrap gap-2 mb-6">
                    {track.tags && track.tags.length > 0 ? (
                      track.tags.slice(0, 4).map((tag, idx) => (
                        <span 
                          key={idx}
                          className="text-xs px-2 py-1 rounded bg-gray-200 text-gray-600 border border-gray-300"
                        >
                          {tag}
                        </span>
                      ))
                    ) : (
                      <>
                        <span className="text-xs px-2 py-1 rounded bg-gray-200 text-gray-600 border border-gray-300">
                          Coming
                        </span>
                        <span className="text-xs px-2 py-1 rounded bg-gray-200 text-gray-600 border border-gray-300">
                          Soon
                        </span>
                        <span className="text-xs px-2 py-1 rounded bg-gray-200 text-gray-600 border border-gray-300">
                          Track
                        </span>
                      </>
                    )}
                  </div>

                  {/* Footer */}
                  <div className="mt-auto pt-4 border-t border-gray-200">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <BookOpen className="w-4 h-4 text-gray-400" />
                        <span className="text-sm text-gray-500">
                          {track.lessonCount || 'TBD'} lessons
                        </span>
                      </div>
                      
                      <div className="text-sm text-gray-500 font-medium">
                        Launching Soon
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            );
          }

          return (
          

            <Link
              key={track.slug}
              href={`/learn/tracks/${track.slug}`}
              className="group relative bg-white border border-gray-200 rounded-2xl p-6 hover:border-blue-300 hover:shadow-lg transition-all duration-300 overflow-hidden flex flex-col"
            >
              {/* Premium gradient overlay */}
              {isPremium && (
                <div className="absolute inset-0 bg-gradient-to-br from-blue-50/30 to-cyan-50/30 opacity-0 group-hover:opacity-100 transition-opacity duration-300" />
              )}

              <div className="relative flex-1 flex flex-col">
                {/* Header */}
                <div className="flex items-start gap-4 mb-4">
                  <div className={`w-12 h-12 rounded-xl flex items-center justify-center flex-shrink-0 ${
                    isPremium 
                      ? 'bg-gradient-to-br from-blue-500 to-cyan-500 text-white'
                      : 'bg-gray-100 text-gray-700'
                  }`}>
                    <TrackIcon type={track.title} />
                  </div>
                  
                  <div className="flex-1 min-w-0 pr-12">
                    <h2 className="text-lg font-bold text-gray-900 group-hover:text-blue-700 transition-colors line-clamp-1">
                      {track.title}
                    </h2>
                    <div className="flex items-center gap-3 mt-1">
                      <div className="flex items-center gap-1 text-sm text-gray-600">
                        <Clock className="w-3 h-3 flex-shrink-0" />
                        <span>{track.duration || '60 days'}</span>
                      </div>
                      <div className="text-gray-400">‚Ä¢</div>
                      <div className="text-sm font-medium px-2 py-0.5 rounded bg-gray-100 text-gray-700">
                        {track.level || 'Advanced'}
                      </div>
                    </div>
                  </div>
                  
                  {/* Access badge */}
                  <div className="absolute top-6 right-6">
                    {isFree ? (
                      <span className="text-xs font-bold bg-green-100 text-green-800 px-2 py-1 rounded-full">
                        FREE
                      </span>
                    ) : (
                      <span className="text-xs font-bold bg-blue-100 text-blue-800 px-2 py-1 rounded-full flex items-center gap-1">
                        <Lock className="w-3 h-3" />
                        PREMIUM
                      </span>
                    )}
                  </div>
                </div>

                {/* Description */}
                <div className="h-12 mb-4 flex-1">
                  {track.description ? (
                    <p className="text-gray-600 line-clamp-2 leading-relaxed">
                      {track.description}
                    </p>
                  ) : (
                    <p className="text-gray-500 italic">
                      Complete track with hands-on exercises and interview prep
                    </p>
                  )}
                </div>

                {/* Topics */}
                <div className="flex flex-wrap gap-2 mb-6">
                  {track.tags && track.tags.length > 0 ? (
                    track.tags.slice(0, 4).map((tag, idx) => (
                      <span 
                        key={idx}
                        className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200"
                      >
                        {tag}
                      </span>
                    ))
                  ) : (
                    (() => {
                      const title = track.title.toLowerCase();
                      if (title.includes("cpp") || title.includes("c++") || title.includes("systems")) {
                        return <>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            C++
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Systems
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Performance
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Memory
                          </span>
                        </>;
                      } else if (title.includes("template")) {
                        return <>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Templates
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Metaprogramming
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            C++20
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Compile-time
                          </span>
                        </>;
                      } else if (title.includes("hft") || title.includes("latency")) {
                        return <>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            HFT
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Low Latency
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Cache
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Lock-Free
                          </span>
                        </>;
                      } else if (title.includes("eda")) {
                        return <>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            EDA
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Simulation
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Verification
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Systems
                          </span>
                        </>;
                      } else {
                        return <>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            C++
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Systems
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Performance
                          </span>
                          <span className="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 border border-gray-200">
                            Advanced
                          </span>
                        </>;
                      }
                    })()
                  )}
                </div>

                {/* Footer */}
                <div className="mt-auto pt-4 border-t border-gray-100">
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <BookOpen className="w-4 h-4 text-gray-400" />
                      <span className="text-sm text-gray-600">
                        {track.lessonCount || '160'} lessons
                      </span>
                    </div>
                    
                    <div className="flex items-center gap-2">
                      <span className={`text-sm font-medium ${
                        isPremium ? 'text-blue-600' : 'text-gray-600'
                      }`}>
                        {isPremium ? 'Explore Premium ‚Üí' : 'Start Learning ‚Üí'}
                      </span>
                    </div>
                  </div>
                </div>
              </div>
            </Link>
          );
        })}
      </section>

      {/* How to Choose Section */}
      <section className="mt-12 p-6 bg-gray-50 rounded-2xl border border-gray-200">
        <div className="max-w-3xl mx-auto text-center">
          <h3 className="text-xl font-semibold text-gray-900 mb-4">Track Status Guide</h3>
          <div className="grid md:grid-cols-3 gap-6">
            <div className="text-center">
              <div className="w-10 h-10 rounded-lg bg-green-100 text-green-600 flex items-center justify-center mx-auto mb-3">
                <BookOpen className="w-5 h-5" />
              </div>
              <h4 className="font-medium text-gray-900 mb-2">Free Tracks</h4>
              <p className="text-sm text-gray-600">
                Start immediately with core C++ systems fundamentals
              </p>
            </div>
            <div className="text-center">
              <div className="w-10 h-10 rounded-lg bg-blue-100 text-blue-600 flex items-center justify-center mx-auto mb-3">
                <Lock className="w-5 h-5" />
              </div>
              <h4 className="font-medium text-gray-900 mb-2">Premium Tracks</h4>
              <p className="text-sm text-gray-600">
                Advanced content requiring subscription or one-time purchase
              </p>
            </div>
            <div className="text-center">
              <div className="w-10 h-10 rounded-lg bg-amber-100 text-amber-600 flex items-center justify-center mx-auto mb-3">
                <Calendar className="w-5 h-5" />
              </div>
              <h4 className="font-medium text-gray-900 mb-2">Coming Soon</h4>
              <p className="text-sm text-gray-600">
                Tracks in active development, launching in the near future
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* Debug Info (Remove in production) */}
    

      {/* Bottom CTA */}
      <div className="mt-10 text-center">
        <div className="inline-flex items-center gap-2 text-sm text-gray-600 bg-white border border-gray-200 px-4 py-2 rounded-lg">
          <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <span>
            <span className="font-semibold">Pro Tip:</span> Complete one track fully before moving to another
          </span>
        </div>
      </div>
    </div>
    
          <SiteFooter />
          </>
  );
}
=== FILE: src/app/learn/page.tsx ===
import { listContent } from "@/lib/content";
import ContentCard from "@/components/ContentCard";

export default function LearnPage() {
  const lessons = listContent("learn");

  return (
    <main className="mx-auto max-w-4xl px-6 py-12">
      <h1 className="text-3xl font-bold">Learn</h1>
      <p className="mt-2 text-gray-600">
        Structured C++ systems lessons for elite interviews.
      </p>

      <div className="mt-8 grid gap-6">
        {lessons.map((item) => (
          <ContentCard key={item.slug} item={item} />
        ))}
      </div>
    </main>
  );
}


=== FILE: src/app/checkout/page.tsx ===
"use client";

import Script from "next/script";
import { useEffect, useMemo, useState } from "react";
import { useSearchParams } from "next/navigation";

declare global {
  interface Window {
    Razorpay: any;
  }
}

export default function CheckoutPage() {
  const sp = useSearchParams();
  const scope = sp.get("scope") || "track";       // "track" | "site"
  const trackSlug = sp.get("track") || "";
  const plan = (sp.get("plan") || "monthly") as "monthly" | "yearly";

  const title = useMemo(() => {
    if (scope === "site") return `cppvalley Premium (${plan})`;
    return `Track: ${trackSlug} (${plan})`;
  }, [scope, trackSlug, plan]);

  const [loading, setLoading] = useState(false);
  const [err, setErr] = useState<string | null>(null);

  async function startPayment() {
    setErr(null);
    setLoading(true);

    try {
      const res = await fetch("/api/razorpay/create-subscription", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ scope, trackSlug, plan }),
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data?.error || "failed");

      const options = {
        key: data.keyId,
        subscription_id: data.subscriptionId,
        name: "cppvalley",
        description: title,
        theme: { color: "#22d3ee" },
        handler: function () {
          // Payment confirmation comes via webhook (source of truth)
          window.location.href = "/pricing?paid=1";
        },
      };

      const rzp = new window.Razorpay(options);
      rzp.open();
    } catch (e: any) {
      setErr(e?.message || "Payment init failed");
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    // auto-start (optional)
    startPayment();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <div className="mx-auto max-w-xl rounded-2xl border border-white/10 bg-white/5 p-6">
      <Script src="https://checkout.razorpay.com/v1/checkout.js" />
      <h1 className="text-2xl font-bold">Checkout</h1>
      <p className="mt-2 text-white/70 font-mono text-sm">{title}</p>

      {err && <p className="mt-4 text-sm text-red-300">{err}</p>}

      <button
        onClick={startPayment}
        disabled={loading}
        className="mt-6 rounded-xl bg-cyan-500 px-4 py-2 font-semibold text-black hover:bg-cyan-400 disabled:opacity-60"
      >
        {loading ? "Starting‚Ä¶" : "Pay with Razorpay"}
      </button>

      <p className="mt-4 text-xs text-white/50">
        Note: unlocking happens via webhook (may take a few seconds).
      </p>
    </div>
  );
}


=== FILE: src/app/blog/page.tsx ===
import { listContent } from "@/lib/content";
import ContentCard from "@/components/ContentCard";

export default function BlogPage() {
  const posts = listContent("blog");

  return (
    <main className="mx-auto max-w-4xl px-6 py-12">
      <h1 className="text-3xl font-bold">Blog</h1>
      <p className="mt-2 text-gray-600">
        Systems-first C++ articles beyond DSA.
      </p>

      <div className="mt-8 grid gap-6">
        {posts.map((item) => (
          <ContentCard key={item.slug} item={item} />
        ))}
      </div>
    </main>
  );
}


=== FILE: src/app/blog/[slug]/page.tsx ===
import MdxRenderer from "@/components/MdxRenderer";
import { requireContent } from "@/lib/content";

export default async function BlogSlugPage({
  params,
}: {
  params: Promise<{ slug: string }>;
}) {
  const { slug } = await params;
  const { meta, content } = requireContent("blog", slug);

  return (
    <main className="mx-auto max-w-4xl px-6 py-12">
      <h1 className="text-3xl font-bold">{meta.title}</h1>
      {meta.description && (
        <p className="mt-2 text-gray-600 dark:text-gray-300">
          {meta.description}
        </p>
      )}

      {meta.tags && meta.tags.length > 0 && (
        <div className="mt-3 flex flex-wrap gap-2">
          {meta.tags.map((tag) => (
            <span
              key={tag}
              className="text-xs bg-gray-200 text-gray-900 dark:bg-gray-800 dark:text-gray-100 px-2 py-1 rounded"
            >
              {tag}
            </span>
          ))}
        </div>
      )}

      <div className="mt-8">
        <MdxRenderer source={content} />
      </div>
    </main>
  );
}


=== FILE: src/app/layout.tsx ===
// src/app/layout.tsx - COMPLETE (with Providers)
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import Providers from "@/components/Providers";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "cppvalley",
  description: "EDA ‚Ä¢ HFT ‚Ä¢ Low Latency ‚Ä¢ Systems interview mastery",
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" className={inter.className}>
      <body className="min-h-screen bg-white text-gray-900 antialiased">
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

=== FILE: src/app/api/track/[slug]/route.ts ===
// src/app/api/track/[slug]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { requireContent, parseTrackSyllabus } from "@/lib/content";

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ slug: string }> }
) {
  try {
    const { slug } = await params;
    const track = requireContent("tracks", slug);
    const sections = parseTrackSyllabus(track.content);
    
    return NextResponse.json({
      sections,
      meta: track.meta
    });
  } catch (error) {
    return NextResponse.json(
      { error: "Track not found" },
      { status: 404 }
    );
  }
}
=== FILE: src/app/api/progress/last/route.ts ===
import { NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import { authOptions } from "@/auth";
import { getServerSession } from "next-auth";

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  const email = session?.user?.email;

  if (!email) {
    return NextResponse.json({ ok: false, error: "unauthorized" }, { status: 401 });
  }

  const { trackSlug, lessonSlug } = await req.json();

  if (!trackSlug || !lessonSlug) {
    return NextResponse.json({ ok: false, error: "missing_params" }, { status: 400 });
  }

  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) {
    return NextResponse.json({ ok: false, error: "user_not_found" }, { status: 404 });
  }

  await prisma.progress.upsert({
    where: { userId_trackSlug: { userId: user.id, trackSlug } },
    update: { lastLessonSlug: lessonSlug },
    create: { userId: user.id, trackSlug, lastLessonSlug: lessonSlug },
  });

  return NextResponse.json({ ok: true });
}

=== FILE: src/app/api/auth/[...nextauth]/route.ts ===
import NextAuth from "next-auth";
import { authOptions } from "@/auth";

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

=== FILE: src/app/api/razorpay/webhook/route.ts ===
import { NextResponse } from "next/server";
import crypto from "crypto";
import { prisma } from "@/lib/prisma";

function verifySignature(rawBody: string, signature: string) {
  const secret = process.env.RAZORPAY_WEBHOOK_SECRET!;
  const expected = crypto.createHmac("sha256", secret).update(rawBody).digest("hex");
  return expected === signature;
}

export async function POST(req: Request) {
  const signature = req.headers.get("x-razorpay-signature") || "";
  const rawBody = await req.text();

  if (!verifySignature(rawBody, signature)) {
    return NextResponse.json({ ok: false }, { status: 401 });
  }

  const event = JSON.parse(rawBody);
  const ev = event?.event;

  // We primarily care about activation/charge events
  if (!ev?.startsWith("subscription.")) {
    return NextResponse.json({ ok: true });
  }

  const sub = event?.payload?.subscription?.entity;
  const notes = sub?.notes || {};
  const userId = notes.userId as string | undefined;
  const scope = notes.scope as string | undefined; // "track" | "site"
  const trackSlug = (notes.trackSlug as string | undefined) || null;
  const plan = (notes.plan as string | undefined) || "monthly";

  if (!userId || !scope) return NextResponse.json({ ok: true });

  const status = sub?.status; // "active", "authenticated", "created", "cancelled" etc.

  if (status === "active") {
    await prisma.entitlement.upsert({
      where: {
        // Create a compound unique yourself later; for now do findFirst+update
        id: "dummy", // not used
      } as any,
      update: {},
      create: {} as any,
    });

    // Safer: find existing entitlement row and update, else create
    const existing = await prisma.entitlement.findFirst({
      where: { userId, scope, trackSlug: scope === "track" ? trackSlug : null },
    });

    if (existing) {
      await prisma.entitlement.update({
        where: { id: existing.id },
        data: {
          status: "active",
          plan,
          razorpaySubscriptionId: sub.id,
        },
      });
    } else {
      await prisma.entitlement.create({
        data: {
          userId,
          scope,
          trackSlug: scope === "track" ? trackSlug : null,
          plan,
          status: "active",
          razorpaySubscriptionId: sub.id,
        },
      });
    }
  }

  if (status === "cancelled") {
    await prisma.entitlement.updateMany({
      where: { razorpaySubscriptionId: sub.id },
      data: { status: "canceled" },
    });
  }

  return NextResponse.json({ ok: true });
}


=== FILE: src/app/api/razorpay/create-subscription/route.ts ===
import Razorpay from "razorpay";
import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/auth";
import { prisma } from "@/lib/prisma";
import { trackPlanIds, sitePlanIds } from "@/lib/razorpayPlans";

export async function POST(req: Request) {
  const session = await getServerSession(authOptions);
  const email = session?.user?.email;
  if (!email) return NextResponse.json({ error: "unauthorized" }, { status: 401 });

  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) return NextResponse.json({ error: "user_not_found" }, { status: 404 });

  const { scope, trackSlug, plan } = await req.json();
  // scope: "track" | "site"
  // plan: "monthly" | "yearly"

  if (!scope || !plan) {
    return NextResponse.json({ error: "missing_params" }, { status: 400 });
  }

  let plan_id: string | undefined;
  if (scope === "track") {
    if (!trackSlug) return NextResponse.json({ error: "missing_trackSlug" }, { status: 400 });
    plan_id = trackPlanIds?.[trackSlug]?.[plan];
  } else if (scope === "site") {
    plan_id = sitePlanIds?.[plan];
  }

  if (!plan_id || plan_id.includes("plan_XXXXXXXX") || plan_id.includes("plan_SITE")) {
    return NextResponse.json(
      { error: "plan_id_not_configured", hint: "Set Razorpay plan_id in src/lib/razorpayPlans.ts" },
      { status: 400 }
    );
  }

  const razorpay = new Razorpay({
    key_id: process.env.RAZORPAY_KEY_ID!,
    key_secret: process.env.RAZORPAY_KEY_SECRET!,
  });

  const subscription = await razorpay.subscriptions.create({
    plan_id,
    total_count: plan === "yearly" ? 1 : 12, // monthly: 12 cycles (you can change later)
    quantity: 1,
    customer_notify: 1,
    notes: {
      userId: user.id,
      email,
      scope,
      trackSlug: trackSlug ?? "",
      plan,
    },
  });

  return NextResponse.json({
    subscriptionId: subscription.id,
    keyId: process.env.RAZORPAY_KEY_ID!,
  });
}

=== FILE: src/app/conferences/[...slug]/page.tsx ===
import SiteHeader from "@/components/SiteHeader";
import SiteFooter from "@/components/SiteFooter";
import MdxRenderer from "@/components/MdxRenderer";
import { requireContent } from "@/lib/content";
import Link from "next/link";
import { notFound } from "next/navigation";
import OnThisPage from "@/components/OnThisPage";

type PageProps = {
  params: Promise<{ slug?: string[] }>;
};

export default async function ConferenceSlugPage({ params }: PageProps) {
  const resolvedParams = await params;

  if (!resolvedParams.slug || resolvedParams.slug.length === 0) {
    notFound();
  }

  const slugPath = resolvedParams.slug.join("/");
  const { meta, content } = requireContent("conferences", slugPath);

  return (
    <>
      <SiteHeader />

      <main className="relative bg-white text-gray-900">
        {/* abstract background */}
        <div className="pointer-events-none absolute inset-0">
          <div className="absolute -top-40 -left-40 h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
          <div className="absolute top-1/3 -right-40 h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
        </div>

        <div className="relative mx-auto max-w-6xl px-6 py-12">
          <div className="flex items-start gap-10">
            {/* main */}
            <div className="min-w-0 flex-1">
              <Link
                href="/conferences"
                className="inline-flex items-center gap-1 text-sm font-mono text-cyan-600 hover:text-cyan-700"
              >
                ‚Üê conferences
              </Link>

              <header className="mt-6 rounded-2xl border border-gray-200 bg-white/70 backdrop-blur p-6">
                <h1 className="text-3xl font-bold tracking-tight">{meta.title}</h1>

                {meta.description && (
                  <p className="mt-3 max-w-2xl text-gray-600 leading-relaxed">
                    {meta.description}
                  </p>
                )}

                {(meta.date || meta.tags?.length) && (
                  <div className="mt-4 flex flex-wrap gap-2">
                    {meta.date && (
                      <span className="rounded-full border border-gray-200 bg-gray-50 px-3 py-1 text-xs font-mono text-gray-600">
                        {meta.date}
                      </span>
                    )}
                    {meta.tags?.map((tag) => (
                      <span
                        key={tag}
                        className="rounded-full border border-cyan-200 bg-cyan-50 px-3 py-1 text-xs font-mono text-cyan-700"
                      >
                        {tag}
                      </span>
                    ))}
                  </div>
                )}
              </header>

              {/* content */}
              <article
                id="mdx-article"
                className="mt-10 prose prose-slate prose-headings:font-semibold prose-headings:tracking-tight
                           prose-code:font-mono prose-code:text-cyan-700 prose-code:bg-cyan-50 prose-code:px-1 prose-code:py-0.5 prose-code:rounded-md
                           prose-pre:bg-gray-950 prose-pre:text-gray-100 prose-pre:border prose-pre:border-gray-800
                           max-w-none"
              >
                <MdxRenderer source={content} />
              </article>

              <div className="mt-16 flex items-center justify-between border-t border-gray-200 pt-6">
                <Link
                  href="/conferences"
                  className="text-sm font-mono text-gray-500 hover:text-gray-700"
                >
                  ‚Üê All conferences
                </Link>

                <span className="text-sm font-mono text-gray-400">
                  cppvalley ¬∑ systems-first
                </span>
              </div>
            </div>

            {/* toc */}
            <OnThisPage containerId="mdx-article" />
          </div>
        </div>
      </main>

      <SiteFooter />
    </>
  );
}

=== FILE: src/app/conferences/ConferencesClient.tsx ===
"use client";

import Link from "next/link";
import { useMemo, useState } from "react";
import type { ContentMeta } from "@/lib/content";

function getYear(date?: string) {
  if (!date) return "Unknown";
  const d = new Date(date);
  const y = d.getFullYear();
  return Number.isFinite(y) ? String(y) : "Unknown";
}

function relevanceScore(tags?: string[]) {
  const t = (tags ?? []).map((x) => x.toLowerCase());
  const keywords = [
    "eda",
    "hft",
    "systems",
    "low-latency",
    "latency",
    "concurrency",
    "memory",
    "abi",
    "performance",
    "lock-free",
    "allocator",
    "cache",
    "numa",
    "kernel",
    "simulation",
  ];
  let score = 0;
  for (const k of keywords) if (t.includes(k)) score++;
  if (score >= 7) return 3;
  if (score >= 3) return 2;
  if (score >= 1) return 1;
  return 0;
}

function RelevancePips({ score }: { score: number }) {
  return (
    <div className="flex items-center gap-1">
      {[0, 1, 2].map((i) => (
        <span
          key={i}
          className={[
            "h-1.5 w-4 rounded-full border",
            i < score
              ? "bg-cyan-600 border-cyan-600"
              : "bg-gray-100 border-gray-200",
          ].join(" ")}
        />
      ))}
    </div>
  );
}

export default function ConferencesClient({
  posts,
}: {
  posts: ContentMeta[];
}) {
  const [q, setQ] = useState("");

  const filtered = useMemo(() => {
    const s = q.trim().toLowerCase();
    if (!s) return posts;

    return posts.filter((it) => {
      const hay = [
        it.title,
        it.description ?? "",
        it.slug,
        ...(it.tags ?? []),
        it.date ?? "",
      ]
        .join(" ")
        .toLowerCase();

      return hay.includes(s);
    });
  }, [posts, q]);

  const grouped = useMemo(() => {
    const g: Record<string, ContentMeta[]> = {};
    for (const it of filtered) {
      const year = getYear(it.date);
      (g[year] ||= []).push(it);
    }
    return g;
  }, [filtered]);

  const years = useMemo(() => {
    return Object.keys(grouped).sort((a, b) => {
      if (a === "Unknown") return 1;
      if (b === "Unknown") return -1;
      return Number(b) - Number(a);
    });
  }, [grouped]);

  return (
    <main className="relative bg-white text-gray-900">
      {/* abstract background */}
      <div className="pointer-events-none absolute inset-0">
        <div className="-top-40 -left-40 absolute h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
        <div className="top-1/2 -right-40 absolute h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
      </div>

      <div className="relative mx-auto max-w-5xl px-6 py-12">
        <header className="flex flex-col gap-6 sm:flex-row sm:items-end sm:justify-between">
          <div>
            <h1 className="text-3xl font-bold tracking-tight">
              C++ Conferences
            </h1>
            <p className="mt-3 text-gray-600">
              MDX-powered conference summaries with systems-level interview
              relevance.
            </p>
          </div>

          <div className="w-full sm:w-[320px] rounded-2xl border border-gray-200 bg-white/70 backdrop-blur px-4 py-3">
            <div className="text-xs font-mono text-gray-500">SEARCH</div>
            <input
              value={q}
              onChange={(e) => setQ(e.target.value)}
              placeholder="title, tag, year..."
              className="mt-2 w-full bg-transparent outline-none text-sm"
            />
          </div>
        </header>

        <div className="mt-10 space-y-6">
          {years.map((year) => (
            <details
              key={year}
              open={q !== "" || year === years[0]}
              className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur"
            >
              <summary className="cursor-pointer list-none px-5 py-4 flex justify-between">
                <div className="font-semibold">{year}</div>
                <div className="text-xs font-mono text-gray-500">
                  {grouped[year].length} posts
                </div>
              </summary>

              <div className="px-5 pb-5 grid gap-4">
                {grouped[year].map((item) => {
                  const score = relevanceScore(item.tags);
                  return (
                    <Link
                      key={item.slug}
                      href={`/conferences/${item.slug}`}
                      className="group rounded-xl border border-gray-200 bg-white px-5 py-4 hover:border-cyan-300 hover:shadow-sm transition"
                    >
                      <div className="flex justify-between gap-6">
                        <div>
                          <div className="flex items-center gap-3">
                            <h2 className="font-semibold group-hover:text-cyan-700">
                              {item.title}
                            </h2>
                            <RelevancePips score={score} />
                          </div>

                          {item.description && (
                            <p className="mt-2 text-sm text-gray-600">
                              {item.description}
                            </p>
                          )}
                        </div>
                        <span className="text-gray-400 group-hover:text-cyan-600">
                          ‚Üí
                        </span>
                      </div>
                    </Link>
                  );
                })}
              </div>
            </details>
          ))}
        </div>
      </div>
    </main>
  );
}

=== FILE: src/app/conferences/page.tsx ===
import SiteHeader from "@/components/SiteHeader";
import SiteFooter from "@/components/SiteFooter";
import { listContent } from "@/lib/content";
import ConferencesClient from "./ConferencesClient";

export default function ConferencesPage() {
  // ‚úÖ Runs on server ‚Üí fs is allowed
  const posts = listContent("conferences");

  return (
    <>
      <SiteHeader />
      <ConferencesClient posts={posts} />
      <SiteFooter />
    </>
  );
}

=== FILE: src/app/page.tsx ===
// src/app/page.tsx - COMPLETE (Light theme, same content, fixed compilation)
"use client";

import RegularPageLayout from "@/components/RegularPageLayout";
import Link from "next/link";
import { useEffect, useRef, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import {
  Calendar,
  CheckCircle2,
  ChevronRight,
  Cpu,
  Play,
  Send,
  Sparkles,
  Target,
  Terminal,
  TrendingUp,
  Rocket,
} from "lucide-react";

const tracks = [
  {
    title: "60-Day C++ Systems Mastery",
    href: "/learn/tracks/60-day-cpp-interview",
    duration: "60 days",
    level: "Intermediate",
    access: "Launched",
    bullets: ["ABI & Object Model", "Concurrency & Memory Model", "Lock-Free Design", "Low-Latency Performance"],
    tone: "emerald" as const,
    status: "live",
  },
  {
    title: "Low-Latency C++ for HFT",
    href: "#",
    duration: "30‚Äì45 days",
    level: "Advanced",
    access: "Coming Soon",
    bullets: ["Latency budgets", "Ring buffers", "NUMA & cache", "Micro-benchmarking"],
    tone: "cyan" as const,
    status: "soon",
  },
  {
    title: "EDA Simulation Kernel Deep Dive",
    href: "#",
    duration: "30 days",
    level: "Advanced",
    access: "Coming Soon",
    bullets: ["Event queues", "Delta cycles", "Scheduling", "Perf pitfalls"],
    tone: "violet" as const,
    status: "soon",
  },
  {
    title: "Templates & Compile-Time Mastery",
    href: "#",
    duration: "21‚Äì30 days",
    level: "Advanced",
    access: "Coming Soon",
    bullets: ["Instantiation model", "SFINAE ‚Üí Concepts", "constexpr/consteval", "Type traits"],
    tone: "amber" as const,
    status: "soon",
  },
];

const companies = [
  { name: "Siemens EDA - LMTS", logo: "35+ lpa", tone: "emerald", welcome: "Welcome to Siemens EDA!" },
  { name: "Synopsys - Senior Staff", logo: "40+ lpa", tone: "violet", welcome: "Welcome to Synopsys!" },
  { name: "Ansys - Lead C++", logo: "45+ lpa", tone: "cyan", welcome: "Welcome to Ansys!" },
  { name: "Jane Street - Quant C++", logo: "95+ lpa", tone: "amber", welcome: "Welcome to Jane Street!" },
  { name: "Tower Research - SDE-III", logo: "70+ lpa", tone: "rose", welcome: "Welcome to Tower Research!" },
  { name: "Google - Infrastructure Engineer", logo: "65+ lpa", tone: "blue", welcome: "Welcome to Google!" },
  { name: "Adobe - Computer Scientist I/II", logo: "80+ lpa", tone: "pink", welcome: "Welcome to Adobe!" },
  { name: "Meta Systems - Silicon Engineer", logo: "90+ lpa", tone: "indigo", welcome: "Welcome to Meta!" },
];

const interviewTiles = [
  {
    title: "Siemens EDA Memory Model Deep Dive",
    href: "/interviews",
    tag: "EDA",
    desc: "Virtual inheritance, vtable layout, ABI compatibility across toolchains.",
    tone: "emerald" as const,
  },
  {
    title: "Jane Street's C++ Tradeoff Analysis",
    href: "/interviews",
    tag: "HFT",
    desc: "Move vs copy semantics in latency-critical paths, exception safety guarantees.",
    tone: "amber" as const,
  },
  {
    title: "Google's Systems Debugging Session",
    href: "/interviews",
    tag: "Systems",
    desc: "Cache line alignment, false sharing detection, lock-free algorithm validation.",
    tone: "cyan" as const,
  },
];

/* ---------------- C++ Jargons Ticker (LIGHT) ---------------- */
function CppJargonsTicker() {
  const jargons = [
    "virtual destructor",
    "false sharing",
    "vtable layout",
    "dynamic dispatch",
    "RTTI overhead",
    "perfect forwarding",
    "copy elision",
    "EBO optimization",
    "move semantics",
    "SFINAE",
    "CRTP pattern",
    "type erasure",
    "memory model",
    "sequential consistency",
    "happens-before",
    "cache coherence",
    "RAII",
    "smart pointers",
    "placement new",
    "aligned_storage",
    "constexpr",
    "consteval",
    "concepts",
    "ranges",
    "coroutines",
    "modules",
    "three-way comparison",
    "spaceship operator",
    "std::expected",
    "std::optional",
    "std::variant",
    "std::any",
    "PMR allocators",
    "memory_order",
    "atomic fences",
    "lock-free queues",
  ];

  return (
    <div className="bg-white border-y border-gray-200 py-3 overflow-hidden">
      <motion.div
        animate={{ x: [0, -1000] }}
        transition={{ duration: 40, repeat: Infinity, ease: "linear" }}
        className="flex items-center gap-8"
      >
        {[...jargons, ...jargons].map((jargon, idx) => (
          <div key={idx} className="flex items-center gap-4 text-sm font-mono">
            <div className="w-1.5 h-1.5 rounded-full bg-cyan-500/70" />
            <span className="text-gray-700">{jargon}</span>
          </div>
        ))}
      </motion.div>
    </div>
  );
}

/* ---------------- Code Preview Terminal (keep dark card for contrast) ---------------- */
function CodePreviewTerminal() {
  const [activeTab, setActiveTab] = useState<"hft" | "eda" | "systems">("hft");
  const [isSubmitted, setIsSubmitted] = useState(false);
  const [welcomeMessage, setWelcomeMessage] = useState("");
  const codeRef = useRef<HTMLPreElement>(null);

  useEffect(() => {
    const submitInterval = setInterval(() => {
      if (!isSubmitted) {
        setIsSubmitted(true);
        const randomCompany = companies[Math.floor(Math.random() * companies.length)];
        setWelcomeMessage(randomCompany.welcome);

        setTimeout(() => {
          setIsSubmitted(false);
          setWelcomeMessage("");
        }, 1500);
      }
    }, 2000);

    return () => clearInterval(submitInterval);
  }, [isSubmitted]);

  const handleSubmit = () => {
    setIsSubmitted(true);
    const randomCompany = companies[Math.floor(Math.random() * companies.length)];
    setWelcomeMessage(randomCompany.welcome);

    setTimeout(() => {
      setIsSubmitted(false);
      setWelcomeMessage("");
    }, 3000);
  };

  const hftCode = `// HFT Order Matching Engine - Jane Street Style
template<typename OrderBook>
class MatchingEngine {
    alignas(64) OrderBook book_;
    std::atomic<int64_t> sequence_{0};
    std::array<CacheLineAligned<int64_t>, 64> metrics_;
    
    void process_order(Order& order) noexcept {
        auto seq = sequence_.fetch_add(1, std::memory_order_acq_rel);
        order.timestamp = __rdtsc();
        
        if (order.side == Side::BUY) {
            match_against_asks(order);
        } else {
            match_against_bids(order);
        }
        
        publish_market_data(order, seq);
    }
};`;

  const edaCode = `// EDA Simulation Kernel - Synopsys Style
class SimulationKernel {
    struct alignas(64) Event {
        uint64_t timestamp;
        uint64_t delta_cycle;
        uint32_t process_id;
        std::function<void()> callback;
    };
    
    std::priority_queue<Event> event_queue_;
    std::atomic<uint64_t> simulation_time_{0};
    
    void run_simulation() {
        while (!event_queue_.empty()) {
            auto event = event_queue_.top();
            event_queue_.pop();
            event.callback();
            advance_time();
        }
    }
};`;

  const systemsCode = `// Systems-Level Cache Optimization - Google Style
class CacheAwareAllocator {
    static constexpr size_t CACHE_LINE_SIZE = 64;
    void* allocate_aligned(size_t size) {
        void* ptr = nullptr;
        if (posix_memalign(&ptr, CACHE_LINE_SIZE, size) != 0) {
            throw std::bad_alloc();
        }
        return ptr;
    }
};`;

  return (
    <div className="bg-gray-950 border border-gray-800 rounded-xl overflow-hidden shadow-[0_18px_60px_-30px_rgba(0,0,0,0.6)]">
      <div className="border-b border-gray-800">
        <div className="flex">
          {[
            { id: "hft" as const, label: "HFT Systems", icon: TrendingUp },
            { id: "eda" as const, label: "EDA Kernels", icon: Cpu },
            { id: "systems" as const, label: "Systems Debug", icon: Terminal },
          ].map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex items-center gap-2 px-6 py-3 text-sm font-mono transition-colors ${
                activeTab === tab.id
                  ? "text-white bg-white/5 border-b-2 border-cyan-400"
                  : "text-gray-400 hover:text-white hover:bg-white/5"
              }`}
            >
              <tab.icon className="w-4 h-4" />
              {tab.label}
            </button>
          ))}
        </div>
      </div>

      <div className="relative">
        <AnimatePresence mode="wait">
          <motion.div
            key={activeTab}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="relative"
          >
            <div className="absolute top-0 left-0 right-0 h-10 bg-gradient-to-b from-gray-950 to-transparent z-10" />
            <div className="absolute bottom-0 left-0 right-0 h-10 bg-gradient-to-t from-gray-950 to-transparent z-10" />

            <pre
              ref={codeRef}
              className="p-6 text-sm text-gray-200 font-mono overflow-x-auto max-h-[400px] overflow-y-auto"
            >
              <code>
                {activeTab === "hft" && hftCode}
                {activeTab === "eda" && edaCode}
                {activeTab === "systems" && systemsCode}
              </code>
            </pre>

            <div className="absolute top-4 right-4 flex items-center gap-4">
              <div className="flex items-center gap-2">
                <div className="flex gap-1.5">
                  <div className="w-2 h-2 rounded-full bg-red-500" />
                  <div className="w-2 h-2 rounded-full bg-amber-500" />
                  <div className="w-2 h-2 rounded-full bg-emerald-500" />
                </div>
                <span className="text-xs text-gray-500 font-mono">
                  {activeTab === "hft"
                    ? "matching_engine.cpp"
                    : activeTab === "eda"
                    ? "simulation_kernel.cpp"
                    : "cache_optimizer.cpp"}
                </span>
              </div>

              <button
                onClick={handleSubmit}
                disabled={isSubmitted}
                className={`flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-all border ${
                  isSubmitted
                    ? "bg-emerald-950 text-emerald-300 border-emerald-900 cursor-not-allowed"
                    : "bg-cyan-950 text-cyan-300 border-cyan-900 hover:bg-cyan-900/40"
                }`}
              >
                {isSubmitted ? (
                  <>
                    <CheckCircle2 className="w-4 h-4 animate-pulse" />
                    Submitted
                  </>
                ) : (
                  <>
                    <Send className="w-4 h-4" />
                    Submit Solution
                  </>
                )}
              </button>
            </div>
          </motion.div>
        </AnimatePresence>

        <AnimatePresence>
          {welcomeMessage && (
            <motion.div
              initial={{ opacity: 0, scale: 0.92 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.92 }}
              className="absolute inset-0 flex items-center justify-center z-20"
            >
              <div className="relative">
                <div className="absolute -inset-4 bg-gradient-to-r from-emerald-500/20 to-cyan-500/20 rounded-xl blur-xl" />
                <div className="relative bg-gray-950 border border-emerald-500/30 rounded-xl px-8 py-6 shadow-2xl">
                  <div className="flex items-center gap-3 mb-4">
                    <Sparkles className="w-6 h-6 text-emerald-400 animate-pulse" />
                    <h3 className="text-xl font-bold text-white">Congratulations! üéâ</h3>
                  </div>
                  <p className="text-lg text-gray-200 mb-2">{welcomeMessage}</p>
                  <p className="text-sm text-gray-400">
                    Your solution passed all test cases with optimal performance!
                  </p>
                  <div className="mt-4 flex items-center gap-2 text-sm text-emerald-300">
                    <Rocket className="w-4 h-4" />
                    <span>Offer letter incoming in 48 hours</span>
                  </div>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
}

/* ---------------- Success Metrics (LIGHT) ---------------- */
function SuccessMetrics() {
  const metrics = [
    { value: "100%", label: "Technical Round Clearance", icon: Target },
    { value: "35 LPA+", label: "Offer Multiplier", icon: TrendingUp },
    { value: "60 days", label: "Avg. Preparation Time", icon: TrendingUp },
    { value: "2+ years", label: "Avg. Experience Required", icon: TrendingUp },
  ];

  return (
    <div className="grid grid-cols-2 lg:grid-cols-4 gap-6">
      {metrics.map((metric, idx) => (
        <motion.div
          key={idx}
          initial={{ opacity: 0, y: 14 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: idx * 0.08 }}
          className="text-center"
        >
          <div className="inline-flex items-center justify-center w-12 h-12 rounded-xl bg-white border border-gray-200 mb-4 shadow-sm">
            <metric.icon className="w-6 h-6 text-cyan-600" />
          </div>
          <div className="text-2xl font-bold text-gray-900 mb-1">{metric.value}</div>
          <div className="text-sm text-gray-600">{metric.label}</div>
        </motion.div>
      ))}
    </div>
  );
}

/* ---------------- Company Grid (LIGHT) ---------------- */
function CompanyGrid() {
  const [selectedCompany, setSelectedCompany] = useState<string | null>(null);

  return (
    <>
      <div className="grid grid-cols-4 md:grid-cols-8 gap-4">
        {companies.map((company, idx) => (
          <motion.div
            key={company.name}
            initial={{ opacity: 0, scale: 0.96 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ delay: idx * 0.04 }}
            className="group"
            onMouseEnter={() => setSelectedCompany(company.welcome)}
            onMouseLeave={() => setSelectedCompany(null)}
          >
            <div className="aspect-square rounded-xl bg-white border border-gray-200 flex flex-col items-center justify-center p-4 hover:border-gray-300 transition-colors cursor-pointer shadow-sm">
              <div className="text-2xl font-bold mb-2 text-gray-900">{company.logo}</div>
              <div className="text-xs text-gray-700 text-center">{company.name.split(" - ")[0]}</div>
              <div className="text-[10px] text-gray-500 text-center mt-1">{company.name.split(" - ")[1]}</div>
            </div>
          </motion.div>
        ))}
      </div>

      <AnimatePresence>
        {selectedCompany && (
          <motion.div
            initial={{ opacity: 0, y: 10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            className="mt-6 text-center"
          >
            <div className="inline-flex items-center gap-2 px-4 py-2 bg-white border border-gray-200 rounded-lg shadow-sm">
              <Sparkles className="w-4 h-4 text-cyan-600" />
              <span className="text-sm text-gray-800">{selectedCompany}</span>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}

export default function HomePage() {
  const [mounted, setMounted] = useState(false);
  const [showComingSoon, setShowComingSoon] = useState<string | null>(null);

  useEffect(() => setMounted(true), []);

  const handleTrackClick = (track: typeof tracks[number]) => {
    if (track.status === "soon") {
      setShowComingSoon(track.title);
      setTimeout(() => setShowComingSoon(null), 2500);
    }
  };

  if (!mounted) {
    return (
      <div className="min-h-screen bg-white">
        <div className="animate-pulse mx-auto max-w-7xl px-6 py-12">
          <div className="h-10 bg-gray-100 rounded mb-6" />
          <div className="h-96 bg-gray-100 rounded-2xl mb-8" />
          <div className="h-40 bg-gray-100 rounded-2xl" />
        </div>
      </div>
    );
  }

  return (
    <RegularPageLayout>
      <div className="min-h-screen bg-white text-gray-900">
        {/* Ticker */}
        <CppJargonsTicker />

        {/* Hero */}
        <div className="relative">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12 md:py-16">
            <div className="grid lg:grid-cols-2 gap-10 items-center">
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5 }}
              >
                {/* USP Badge */}
                <div className="inline-flex items-center gap-2 bg-white border border-gray-200 rounded-full px-4 py-2 mb-8 shadow-sm">
                  <div className="w-2 h-2 rounded-full bg-emerald-500 animate-pulse" />
                  <span className="text-sm font-mono text-gray-700">
                    CRASH ANY C++ SYSTEMS INTERVIEW
                  </span>
                </div>

                <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold mb-6 tracking-tight">
                  <span className="text-gray-900">C++ Systems</span>
                  <span className="block text-transparent bg-clip-text bg-gradient-to-r from-cyan-600 via-emerald-600 to-violet-600">
                    Interview Mastery
                  </span>
                </h1>

                <p className="text-xl text-gray-600 mb-8 max-w-2xl leading-relaxed">
                  Master the C++ that actually matters in systems interviews.
                  Virtual tables, memory models, concurrency, and performance
                  optimizations that separate seniors from junior engineers.
                </p>

                <div className="mb-8">
                  <SuccessMetrics />
                </div>

                <div className="flex flex-col sm:flex-row gap-4">
                  <Link
                    href="/learn/tracks/60-day-cpp-interview"
                    className="group relative inline-flex items-center justify-center px-8 py-4 bg-gradient-to-r from-emerald-600 to-cyan-600 text-white font-bold hover:from-emerald-700 hover:to-cyan-700 transition-all rounded-lg border border-emerald-500/20 shadow-lg shadow-emerald-500/10 overflow-hidden"
                  >
                    <div className="absolute inset-0 bg-gradient-to-r from-emerald-500/0 via-emerald-500/18 to-emerald-500/0 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-1000" />
                    <Play className="w-5 h-5 mr-2 relative" />
                    <span className="relative">START 60-DAY MASTERY</span>
                  </Link>

                  <Link
                    href="/learn/tracks"
                    className="inline-flex items-center justify-center px-8 py-4 bg-white border border-gray-200 text-gray-900 font-semibold hover:bg-gray-50 transition rounded-lg shadow-sm"
                  >
                    Browse tracks
                  </Link>
                </div>
              </motion.div>

              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.5, delay: 0.1 }}
              >
                <CodePreviewTerminal />
              </motion.div>
            </div>
          </div>
        </div>

        {/* Companies */}
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
          <div className="text-center mb-8">
            <div className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-white border border-gray-200 mb-4 shadow-sm">
              <Target className="w-4 h-4 text-cyan-600" />
              <span className="text-sm text-gray-700">PLACEMENTS AT</span>
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-4">Where You Will Land</h2>
            <p className="text-gray-600 max-w-2xl mx-auto">
              Master the C++ patterns and systems thinking that top companies actually test in interviews.
              Hover over companies to see your welcome message!
            </p>
          </div>

          <div className="mb-12">
            <CompanyGrid />
          </div>
        </div>

        {/* Tracks */}
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
          <div className="flex items-center justify-between mb-8">
            <div>
              <div className="flex items-center gap-2 mb-2">
                <div className="w-1.5 h-1.5 rounded-full bg-emerald-500 animate-pulse" />
                <span className="text-sm font-mono text-gray-600">SPECIALIZED TRACKS</span>
              </div>
              <h2 className="text-2xl font-bold text-gray-900">Master Production-Grade C++</h2>
            </div>
            <div className="text-sm text-gray-600 font-mono">
              {tracks.filter((t) => t.status === "live").length} LIVE ‚Ä¢{" "}
              {tracks.filter((t) => t.status === "soon").length} SOON
            </div>
          </div>

          <div className="grid lg:grid-cols-2 gap-6">
            {tracks.map((track, idx) => (
              <motion.div
                key={track.title}
                initial={{ opacity: 0, y: 14 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ delay: idx * 0.08 }}
                onClick={() => handleTrackClick(track)}
              >
                {track.status === "live" ? (
                  <Link href={track.href}>
                    <div className="bg-white border border-gray-200 rounded-xl p-6 hover:border-gray-300 transition-colors group cursor-pointer shadow-sm">
                      <div className="flex items-start justify-between mb-4">
                        <div>
                          <div className="flex items-center gap-2 mb-2">
                            <div className="w-2 h-2 rounded-full bg-emerald-500 animate-pulse" />
                            <span className="text-xs font-mono text-gray-600">{track.duration}</span>
                          </div>
                          <h3 className="text-xl font-bold text-gray-900 group-hover:text-emerald-700 transition-colors">
                            {track.title}
                          </h3>
                        </div>
                        <div className="px-3 py-1 rounded-full text-xs font-bold bg-emerald-50 text-emerald-700 border border-emerald-100">
                          {track.access}
                        </div>
                      </div>

                      <div className="grid grid-cols-2 gap-3 mb-6">
                        {track.bullets.map((bullet, i) => (
                          <div key={i} className="flex items-start gap-2">
                            <div className="w-1.5 h-1.5 rounded-full mt-1.5 bg-emerald-500/50" />
                            <span className="text-sm text-gray-700">{bullet}</span>
                          </div>
                        ))}
                      </div>

                      <div className="flex items-center justify-between pt-6 border-t border-gray-200">
                        <div className="text-sm text-gray-600">{track.level} ‚Ä¢ Enrollment Open</div>
                        <div className="flex items-center gap-2 text-emerald-700 font-medium">
                          <span>Start Learning</span>
                          <ChevronRight className="w-4 h-4" />
                        </div>
                      </div>
                    </div>
                  </Link>
                ) : (
                  <div className="bg-gray-50 border border-gray-200 rounded-xl p-6 cursor-not-allowed">
                    <div className="flex items-start justify-between mb-4">
                      <div>
                        <div className="flex items-center gap-2 mb-2">
                          <div className="w-2 h-2 rounded-full bg-gray-300" />
                          <span className="text-xs font-mono text-gray-500">{track.duration}</span>
                        </div>
                        <h3 className="text-xl font-bold text-gray-700">{track.title}</h3>
                      </div>
                      <div className="px-3 py-1 rounded-full text-xs font-bold bg-white text-gray-600 border border-gray-200">
                        {track.access}
                      </div>
                    </div>

                    <div className="grid grid-cols-2 gap-3 mb-6">
                      {track.bullets.map((bullet, i) => (
                        <div key={i} className="flex items-start gap-2">
                          <div className="w-1.5 h-1.5 rounded-full mt-1.5 bg-gray-300" />
                          <span className="text-sm text-gray-600">{bullet}</span>
                        </div>
                      ))}
                    </div>

                    <div className="flex items-center justify-between pt-6 border-t border-gray-200">
                      <div className="text-sm text-gray-600">{track.level} ‚Ä¢ Launching Soon</div>
                      <div className="text-gray-600 font-medium">Coming Next Week</div>
                    </div>
                  </div>
                )}
              </motion.div>
            ))}
          </div>

          <AnimatePresence>
            {showComingSoon && (
              <motion.div
                initial={{ opacity: 0, y: 14 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 14 }}
                className="fixed bottom-8 left-1/2 transform -translate-x-1/2 z-50"
              >
                <div className="bg-white border border-gray-200 rounded-lg px-6 py-4 shadow-xl">
                  <div className="flex items-center gap-3">
                    <Calendar className="w-5 h-5 text-cyan-600" />
                    <div>
                      <div className="font-medium text-gray-900">{showComingSoon}</div>
                      <div className="text-sm text-gray-600">Launching next week</div>
                    </div>
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>

        {/* Interviews */}
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
          <div className="flex items-center justify-between mb-8">
            <div>
              <div className="flex items-center gap-2 mb-2">
                <div className="w-1.5 h-1.5 rounded-full bg-cyan-600 animate-pulse" />
                <span className="text-sm font-mono text-gray-600">INTERVIEW DEEP DIVES</span>
              </div>
              <h2 className="text-2xl font-bold text-gray-900">Real Interview Scenarios</h2>
            </div>
            <Link href="/interviews" className="text-cyan-700 hover:text-cyan-900 font-mono text-sm">
              VIEW ARCHIVE ‚Üí
            </Link>
          </div>

          <div className="grid md:grid-cols-3 gap-6">
            {interviewTiles.map((interview) => (
              <Link
                key={interview.title}
                href={interview.href}
                className="bg-white border border-gray-200 rounded-xl p-6 hover:border-gray-300 transition-colors group shadow-sm"
              >
                <div className="flex items-center justify-between mb-4">
                  <div className="px-3 py-1 rounded-full text-xs font-bold bg-gray-50 text-gray-700 border border-gray-200">
                    {interview.tag}
                  </div>
                  <div className="text-gray-400 group-hover:text-cyan-700 transition-colors">
                    <ChevronRight className="w-4 h-4" />
                  </div>
                </div>
                <h3 className="text-lg font-bold text-gray-900 mb-3 group-hover:text-cyan-800 transition-colors">
                  {interview.title}
                </h3>
                <p className="text-gray-600 text-sm">{interview.desc}</p>
              </Link>
            ))}
          </div>
        </div>

        {/* Final CTA */}
        <div className="border-t border-gray-200 bg-gray-50">
          <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-20 text-center">
            <div className="inline-flex items-center gap-2 bg-white border border-gray-200 rounded-full px-4 py-2 mb-6 shadow-sm">
              <div className="w-2 h-2 rounded-full bg-emerald-500 animate-pulse" />
              <span className="text-sm font-mono text-gray-700">COHORT STARTS SOON</span>
            </div>

            <h2 className="text-3xl md:text-4xl font-bold text-gray-900 mb-6">
              <span className="block">Master the C++ That Gets You</span>
              <span className="text-transparent bg-clip-text bg-gradient-to-r from-emerald-600 to-cyan-600">
                Senior & Staff Level Offers
              </span>
            </h2>

            <p className="text-xl text-gray-600 mb-8 max-w-2xl mx-auto">
              Join engineers who've cracked systems interviews at top companies with our production-focused curriculum.
            </p>

            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <Link
                href="/learn/tracks/60-day-cpp-interview"
                className="inline-flex items-center justify-center px-8 py-4 bg-gradient-to-r from-emerald-600 to-cyan-600 text-white font-bold hover:from-emerald-700 hover:to-cyan-700 transition-all rounded-lg border border-emerald-500/20 shadow-lg shadow-emerald-500/10"
              >
                <Play className="w-5 h-5 mr-2" />
                ENROLL IN 60-DAY MASTERY
              </Link>

              <Link
                href="/pricing"
                className="inline-flex items-center justify-center px-8 py-4 bg-white border border-gray-200 text-gray-900 font-semibold hover:bg-gray-100 transition rounded-lg shadow-sm"
              >
                View pricing
              </Link>
            </div>

            <div className="mt-8 text-sm text-gray-600">
              Next cohort starts: <span className="text-emerald-700 font-mono">March 15, 2024</span>
            </div>
          </div>
        </div>
      </div>
    </RegularPageLayout>
  );
}

=== FILE: src/app/pricing/PricingClient.tsx ===
"use client";

import Link from "next/link";
import type { TrackMeta } from "@/lib/content";

function formatPrice(p?: number) {
  if (!p || p <= 0) return "Free";
  return `‚Çπ${p.toLocaleString("en-IN")}`;
}

export default function PricingClient({ tracks }: { tracks: TrackMeta[] }) {
  return (
    <main className="relative bg-white text-gray-900">
      {/* abstract background ‚Äì SAME as conferences/interviews */}
      <div className="pointer-events-none absolute inset-0">
        <div className="absolute -top-40 -left-40 h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
        <div className="absolute top-1/2 -right-40 h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
      </div>

      <div className="relative mx-auto max-w-6xl px-6 py-12">
        {/* header ‚Äì SAME rhythm */}
        <header className="max-w-2xl">
          <h1 className="text-3xl font-bold tracking-tight">Pricing</h1>
          <p className="mt-3 text-gray-600 leading-relaxed">
            Transparent, per-track pricing. No subscriptions. Lifetime access
            to deep, systems-first C++ interview content.
          </p>
        </header>

        {/* pricing grid */}
        <div className="mt-12 grid gap-6 sm:grid-cols-2 lg:grid-cols-3">
          {tracks.map((track) => {
            const paid = (track.price ?? 0) > 0;

            return (
              <div
                key={track.slug}
                className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur p-6
                           flex flex-col justify-between
                           hover:border-cyan-300 hover:shadow-sm transition"
              >
                {/* top */}
                <div>
                  <div className="flex items-start justify-between gap-4">
                    <h2 className="text-lg font-semibold leading-snug">
                      {track.title}
                    </h2>
                    {track.level && (
                      <span className="text-xs font-mono text-gray-500">
                        {track.level}
                      </span>
                    )}
                  </div>

                  {track.description && (
                    <p className="mt-3 text-sm text-gray-600 leading-relaxed">
                      {track.description}
                    </p>
                  )}

                  <div className="mt-4 flex flex-wrap gap-2">
                    {track.duration && (
                      <span className="rounded-full border border-gray-200 bg-gray-50 px-3 py-1 text-xs font-mono text-gray-600">
                        {track.duration}
                      </span>
                    )}
                    {track.lessonCount && (
                      <span className="rounded-full border border-gray-200 bg-gray-50 px-3 py-1 text-xs font-mono text-gray-600">
                        {track.lessonCount} lessons
                      </span>
                    )}
                  </div>
                </div>

                {/* bottom ‚Äì SAME footer style */}
                <div className="mt-6 border-t border-gray-200 pt-4 flex items-center justify-between gap-4">
                  <div className="text-2xl font-bold text-cyan-700">
                    {formatPrice(track.price)}
                  </div>

                  <div className="flex items-center gap-2">
                    {/* View */}
                    <Link
                      href={`/learn/tracks/${track.slug}`}
                      className="rounded-xl border border-gray-300 px-3 py-2 text-sm
                                 font-medium text-gray-700 hover:bg-gray-50 transition"
                    >
                      View
                    </Link>

                    {/* Purchase / Start */}
                    {paid ? (
                      <button
                        onClick={() => {
                          // payment hook later
                          alert(`Purchase flow for "${track.title}" coming soon`);
                        }}
                        className="rounded-xl bg-cyan-600 px-4 py-2 text-sm
                                   font-semibold text-white hover:bg-cyan-700 transition"
                      >
                        Purchase
                      </button>
                    ) : (
                      <Link
                        href={`/learn/tracks/${track.slug}`}
                        className="rounded-xl bg-emerald-600 px-4 py-2 text-sm
                                   font-semibold text-white hover:bg-emerald-700 transition"
                      >
                        Start
                      </Link>
                    )}
                  </div>
                </div>
              </div>
            );
          })}

          {tracks.length === 0 && (
            <div className="col-span-full rounded-2xl border border-gray-200 bg-white/70 backdrop-blur px-6 py-12 text-center text-gray-600">
              No tracks available yet.
            </div>
          )}
        </div>

        {/* footer note ‚Äì SAME pattern */}
        <div className="mt-16 border-t border-gray-200 pt-6 text-sm font-mono text-gray-400">
          cppvalley ¬∑ pricing ¬∑ mdx-driven
        </div>
      </div>
    </main>
  );
}

=== FILE: src/app/pricing/page.tsx ===
import Link from "next/link";
import SiteHeader from "@/components/SiteHeader";
import SiteFooter from "@/components/SiteFooter";
import { listTracks } from "@/lib/content";

function PriceTag({ price }: { price: number | null }) {
  if (!price) {
    return (
      <div className="text-sm font-mono text-gray-500">
        price not set
      </div>
    );
  }
  return (
    <div className="text-2xl font-bold text-gray-900">
      ‚Çπ{price.toLocaleString("en-IN")}
      <span className="ml-2 text-sm font-mono font-normal text-gray-500">
        per track
      </span>
    </div>
  );
}

export default function PricingPage() {
  const tracks = listTracks();

  return (
    <>
      <SiteHeader />

      <main className="relative bg-white text-gray-900">
        {/* abstract background */}
        <div className="pointer-events-none absolute inset-0">
          <div className="absolute -top-40 -left-40 h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
          <div className="absolute top-1/2 -right-40 h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
        </div>

        <div className="relative mx-auto max-w-5xl px-6 py-12">
          <header className="max-w-2xl">
            <h1 className="text-3xl font-bold tracking-tight">Pricing</h1>
            <p className="mt-3 text-gray-600 leading-relaxed">
              You purchase tracks individually. Each track reads its price from
              its MDX frontmatter.
            </p>
          </header>

          <div className="mt-10 grid gap-6">
            {tracks.map((t) => (
              <div
                key={t.slug}
                className="rounded-2xl border border-gray-200 bg-white p-6 shadow-sm"
              >
                <div className="flex flex-wrap items-start justify-between gap-6">
                  <div className="min-w-0">
                    <div className="text-xs font-mono text-gray-500">
                      {t.duration ?? "track"}
                      {t.level ? ` ¬∑ ${t.level}` : ""}
                    </div>
                    <h2 className="mt-1 text-xl font-semibold text-gray-900">
                      {t.title}
                    </h2>
                    {t.description && (
                      <p className="mt-2 text-sm text-gray-600 leading-relaxed max-w-2xl">
                        {t.description}
                      </p>
                    )}
                  </div>

                  <div className="text-right">
                    <PriceTag price={(t as any).price ?? null} />
                    <div className="mt-3 flex items-center justify-end gap-3">
                      <Link
                        href={`/learn/tracks/${t.slug}`}
                        className="rounded-xl border border-gray-200 bg-white px-4 py-2 text-sm hover:bg-gray-50 transition"
                      >
                        View track
                      </Link>
                      <Link
                        href={`/checkout?track=${t.slug}&plan=monthly`}
                        className="rounded-xl bg-cyan-600 px-4 py-2 text-sm font-semibold text-white hover:bg-cyan-700 transition"
                      >
                        Purchase
                      </Link>
                    </div>
                  </div>
                </div>
              </div>
            ))}

            {tracks.length === 0 && (
              <div className="rounded-xl border border-gray-200 bg-gray-50 px-6 py-12 text-center text-gray-500">
                No tracks found.
              </div>
            )}
          </div>

          <div className="mt-12 border-t border-gray-200 pt-6 text-xs font-mono text-gray-400">
            cppvalley ¬∑ pricing ¬∑ per-track purchase
          </div>
        </div>
      </main>

      <SiteFooter />
    </>
  );
}

=== FILE: src/app/globals.css ===
/* src/app/globals.css - CLEAN */
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

/* Allow normal scrolling */
html, body {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-sans);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* DeepSeek Prose Styling */
.deepseek-prose {
  max-width: none;
  font-size: 16px;
  line-height: 1.75;
  letter-spacing: -0.003em;
}

.deepseek-prose h1 {
  font-size: 2.25rem;
  font-weight: 700;
  margin-bottom: 2rem;
  margin-top: 0;
  padding-bottom: 1.5rem;
  border-bottom: 1px solid #e5e7eb;
  color: #111827;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: #f1f5f9;
}

::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 3px;
}
=== FILE: src/app/interviews/InterviewsClient.tsx ===
"use client";

import Link from "next/link";
import { useMemo, useState } from "react";
import type { ContentMeta } from "@/lib/content";

function getYear(date?: string) {
  if (!date) return "Unknown";
  const d = new Date(date);
  const y = d.getFullYear();
  return Number.isFinite(y) ? String(y) : "Unknown";
}

// Tag-driven relevance (no per-post config)
function relevanceScore(tags?: string[]) {
  const t = (tags ?? []).map((x) => x.toLowerCase());
  const keywords = [
    "eda",
    "hft",
    "systems",
    "low-latency",
    "latency",
    "concurrency",
    "memory",
    "abi",
    "performance",
    "lock-free",
    "allocator",
    "cache",
    "numa",
    "debugging",
    "kernel",
    "simulation",
    "interview",
  ];
  let score = 0;
  for (const k of keywords) if (t.includes(k)) score++;
  if (score >= 7) return 3;
  if (score >= 3) return 2;
  if (score >= 1) return 1;
  return 0;
}

function RelevancePips({ score }: { score: number }) {
  return (
    <div className="flex items-center gap-1">
      {[0, 1, 2].map((i) => (
        <span
          key={i}
          className={[
            "h-1.5 w-4 rounded-full border",
            i < score
              ? "bg-cyan-600 border-cyan-600"
              : "bg-gray-100 border-gray-200",
          ].join(" ")}
        />
      ))}
    </div>
  );
}

export default function InterviewsClient({ posts }: { posts: ContentMeta[] }) {
  const [q, setQ] = useState("");

  const filtered = useMemo(() => {
    const s = q.trim().toLowerCase();
    if (!s) return posts;

    return posts.filter((it) => {
      const hay = [
        it.title,
        it.description ?? "",
        it.slug,
        ...(it.tags ?? []),
        it.date ?? "",
      ]
        .join(" ")
        .toLowerCase();
      return hay.includes(s);
    });
  }, [posts, q]);

  const grouped = useMemo(() => {
    const g: Record<string, ContentMeta[]> = {};
    for (const it of filtered) {
      const year = getYear(it.date);
      (g[year] ||= []).push(it);
    }
    // newest first inside group
    for (const y of Object.keys(g)) {
      g[y].sort((a, b) => ((a.date ?? "") < (b.date ?? "") ? 1 : -1));
    }
    return g;
  }, [filtered]);

  const years = useMemo(() => {
    return Object.keys(grouped).sort((a, b) => {
      if (a === "Unknown") return 1;
      if (b === "Unknown") return -1;
      return Number(b) - Number(a);
    });
  }, [grouped]);

  return (
    <main className="relative bg-white text-gray-900">
      {/* abstract background */}
      <div className="pointer-events-none absolute inset-0">
        <div className="absolute -top-40 -left-40 h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
        <div className="absolute top-1/2 -right-40 h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
      </div>

      <div className="relative mx-auto max-w-5xl px-6 py-12">
        <header className="flex flex-col gap-6 sm:flex-row sm:items-end sm:justify-between">
          <div className="max-w-2xl">
            <h1 className="text-3xl font-bold tracking-tight">Interview Experiences</h1>
            <p className="mt-3 text-gray-600 leading-relaxed">
              Real interview experiences from EDA, HFT, and systems roles ‚Äî curated into MDX notes.
            </p>
          </div>

          <div className="w-full sm:w-[320px]">
            <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur px-4 py-3">
              <div className="text-xs font-mono text-gray-500">SEARCH</div>
              <input
                value={q}
                onChange={(e) => setQ(e.target.value)}
                placeholder="title, tag, company, year..."
                className="mt-2 w-full bg-transparent outline-none text-sm text-gray-900 placeholder:text-gray-400"
              />
            </div>
            <div className="mt-2 text-xs text-gray-500">
              {filtered.length} result{filtered.length === 1 ? "" : "s"}
            </div>
          </div>
        </header>

        <div className="mt-10 space-y-6">
          {years.map((year) => (
            <details
              key={year}
              open={q.trim() !== "" ? true : year === years[0]}
              className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur"
            >
              <summary className="cursor-pointer list-none px-5 py-4 flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="h-2 w-2 rounded-full bg-cyan-600/70" />
                  <div className="text-lg font-semibold">{year}</div>
                  <div className="text-xs font-mono text-gray-500">
                    {grouped[year]?.length ?? 0} post{(grouped[year]?.length ?? 0) === 1 ? "" : "s"}
                  </div>
                </div>
                <div className="text-sm font-mono text-gray-400">toggle</div>
              </summary>

              <div className="px-5 pb-5 grid gap-4">
                {grouped[year].map((item) => {
                  const score = relevanceScore(item.tags);
                  return (
                    <Link
                      key={item.slug}
                      href={`/interviews/${item.slug}`}
                      className="group rounded-xl border border-gray-200 bg-white px-5 py-4 transition hover:border-cyan-300 hover:shadow-sm"
                    >
                      <div className="flex items-start justify-between gap-6">
                        <div className="min-w-0">
                          <div className="flex items-center gap-3">
                            <h2 className="text-base font-semibold truncate group-hover:text-cyan-700 transition-colors">
                              {item.title}
                            </h2>
                            <RelevancePips score={score} />
                          </div>

                          {item.description && (
                            <p className="mt-2 text-sm text-gray-600 leading-relaxed">
                              {item.description}
                            </p>
                          )}

                          <div className="mt-3 flex flex-wrap gap-2">
                            {item.date && (
                              <span className="rounded-full border border-gray-200 bg-gray-50 px-3 py-1 text-xs font-mono text-gray-600">
                                {item.date}
                              </span>
                            )}
                            {item.tags?.slice(0, 10).map((tag) => (
                              <span
                                key={tag}
                                className="rounded-full border border-cyan-200 bg-cyan-50 px-3 py-1 text-xs font-mono text-cyan-700"
                              >
                                {tag}
                              </span>
                            ))}
                          </div>
                        </div>

                        <div className="flex-shrink-0 text-sm font-mono text-gray-400 group-hover:text-cyan-600 transition-colors">
                          ‚Üí
                        </div>
                      </div>
                    </Link>
                  );
                })}
              </div>
            </details>
          ))}

          {filtered.length === 0 && (
            <div className="rounded-2xl border border-gray-200 bg-white/70 backdrop-blur px-6 py-12 text-center text-gray-600">
              No matching interview posts.
            </div>
          )}
        </div>

        <div className="mt-14 border-t border-gray-200 pt-6 text-sm font-mono text-gray-400">
          cppvalley ¬∑ interviews ¬∑ mdx-powered
        </div>
      </div>
    </main>
  );
}

=== FILE: src/app/interviews/page.tsx ===
import SiteHeader from "@/components/SiteHeader";
import SiteFooter from "@/components/SiteFooter";
import { listContent } from "@/lib/content";
import InterviewsClient from "./InterviewsClient";

export default function InterviewsPage() {
  const posts = listContent("interviews");

  return (
    <>
      <SiteHeader />
      <InterviewsClient posts={posts} />
      <SiteFooter />
    </>
  );
}

=== FILE: src/app/interviews/[slug]/page.tsx ===
import SiteHeader from "@/components/SiteHeader";
import SiteFooter from "@/components/SiteFooter";
import MdxRenderer from "@/components/MdxRenderer";
import { requireContent } from "@/lib/content";
import Link from "next/link";
import { notFound } from "next/navigation";
import OnThisPage from "@/components/OnThisPage";

export default async function InterviewSlugPage({
  params,
}: {
  params: Promise<{ slug?: string }>;
}) {
  const resolved = await params;

  if (!resolved.slug) {
    notFound();
  }

  const { meta, content } = requireContent("interviews", resolved.slug);

  return (
    <>
      <SiteHeader />

      <main className="relative bg-white text-gray-900">
        {/* abstract background */}
        <div className="pointer-events-none absolute inset-0">
          <div className="absolute -top-40 -left-40 h-96 w-96 rounded-full bg-cyan-400/10 blur-3xl" />
          <div className="absolute top-1/3 -right-40 h-96 w-96 rounded-full bg-emerald-400/10 blur-3xl" />
        </div>

        <div className="relative mx-auto max-w-6xl px-6 py-12">
          <div className="flex items-start gap-10">
            {/* main */}
            <div className="min-w-0 flex-1">
              <Link
                href="/interviews"
                className="inline-flex items-center gap-1 text-sm font-mono text-cyan-600 hover:text-cyan-700"
              >
                ‚Üê interviews
              </Link>

              <header className="mt-6 rounded-2xl border border-gray-200 bg-white/70 backdrop-blur p-6">
                <h1 className="text-3xl font-bold tracking-tight">{meta.title}</h1>

                {meta.description && (
                  <p className="mt-3 max-w-2xl text-gray-600 leading-relaxed">
                    {meta.description}
                  </p>
                )}

                {(meta.date || meta.tags?.length) && (
                  <div className="mt-4 flex flex-wrap gap-2">
                    {meta.date && (
                      <span className="rounded-full border border-gray-200 bg-gray-50 px-3 py-1 text-xs font-mono text-gray-600">
                        {meta.date}
                      </span>
                    )}
                    {meta.tags?.map((tag) => (
                      <span
                        key={tag}
                        className="rounded-full border border-cyan-200 bg-cyan-50 px-3 py-1 text-xs font-mono text-cyan-700"
                      >
                        {tag}
                      </span>
                    ))}
                  </div>
                )}
              </header>

              <article
                id="mdx-article"
                className="mt-10 prose prose-slate prose-headings:font-semibold prose-headings:tracking-tight
                           prose-code:font-mono prose-code:text-cyan-700 prose-code:bg-cyan-50 prose-code:px-1 prose-code:py-0.5 prose-code:rounded-md
                           prose-pre:bg-gray-950 prose-pre:text-gray-100 prose-pre:border prose-pre:border-gray-800
                           max-w-none"
              >
                <MdxRenderer source={content} />
              </article>

              <div className="mt-16 flex items-center justify-between border-t border-gray-200 pt-6">
                <Link
                  href="/interviews"
                  className="text-sm font-mono text-gray-500 hover:text-gray-700"
                >
                  ‚Üê All interviews
                </Link>

                <span className="text-sm font-mono text-gray-400">
                  cppvalley ¬∑ systems-first
                </span>
              </div>
            </div>

            {/* toc */}
            <OnThisPage containerId="mdx-article" />
          </div>
        </div>
      </main>

      <SiteFooter />
    </>
  );
}

=== FILE: src/content/learn/abi-object-layout.mdx ===
# Day 1: C++ Memory Layout - From Zero to PhD Level

## Table of Contents
- [Introduction: Why Memory Layout Matters](#introduction-why-memory-layout-matters)
- [Part 1: What is Memory? Let's Start From Atoms](#part-1-what-is-memory-lets-start-from-atoms)
- [Part 2: How CPUs Read Memory - The Hardware Reality](#part-2-how-cpus-read-memory---the-hardware-reality)
- [Part 3: Alignment - The First Law of Memory](#part-3-alignment---the-first-law-of-memory)
- [Part 4: Padding - The Compiler's Secret Handshake](#part-4-padding---the-compilers-secret-handshake)
- [Part 5: Cache Lines - Memory is Not Random Access](#part-5-cache-lines---memory-is-not-random-access)
- [Part 6: False Sharing - When Threads Step on Each Other's Toes](#part-6-false-sharing---when-threads-step-on-each-others-toes)
- [Part 7: NUMA - Memory Has Geography](#part-7-numa---memory-has-geography)
- [Part 8: ABI - The Binary Peace Treaty](#part-8-abi---the-binary-peace-treaty)
- [Part 9: Xcelium Case Study - Theory to Production](#part-9-xcelium-case-study---theory-to-production)

## Introduction: Why Memory Layout Matters

Welcome to Day 1 of our deep dive into C++ memory systems! Today, we're going to start from the absolute basics and build up to PhD-level understanding. 

**The Big Idea**: Your C++ code isn't just logic - it's a blueprint for how electricity should flow through silicon. Understanding memory layout is understanding that blueprint.

## Part 1: What is Memory? Let's Start From Atoms

### 1.1 Memory is Just Switches

```cpp
// Let's start with the smallest unit: a bit
bool bit = true;  // This is either 1 or 0
```

At the hardware level, memory is made of billions of tiny switches (transistors). Each switch can be ON (1) or OFF (0). That's all memory is - a giant sea of switches.

### 1.2 Bytes: Groups of 8 Switches

```cpp
char byte = 'A';  // Actually stores: 01000001
```

A **byte** is 8 bits (8 switches) together. Why 8? Historical reasons, but now it's the universal standard.

### 1.3 Visualizing Memory Addresses

Imagine memory as a giant spreadsheet:

```cpp
// Memory is like this spreadsheet:
Address  | Value (binary)   | Value (decimal)
0x1000   | 01000001         | 65 ('A')
0x1001   | 01000010         | 66 ('B')
0x1002   | 01000011         | 67 ('C')
// ... and so on for billions of rows
```

Every byte has an **address** - a unique number telling the CPU where to find it. Think of it like house numbers on a very long street.

**Key Insight**: Memory isn't "smart" - it doesn't know what data it stores. It's just switches that can be flipped. The CPU interprets these patterns.

## Part 2: How CPUs Read Memory - The Hardware Reality

### 2.1 CPUs Don't Read Bytes One by One

This is the most important misconception to correct:

```cpp
// What you THINK happens:
int x = 42;  // CPU reads 4 bytes individually
// Byte 1 ‚Üí Byte 2 ‚Üí Byte 3 ‚Üí Byte 4

// What ACTUALLY happens (on 64-bit CPU):
int x = 42;  // CPU tries to read 8 bytes at once!
// Reads address 0-7 in one operation
```

Modern CPUs are built to read **word-sized chunks** all at once. A "word" is typically:
- 4 bytes on 32-bit systems
- 8 bytes on 64-bit systems

### 2.2 The Data Bus: Memory's Highway

Think of the CPU as a factory and memory as a warehouse. The data bus is the highway between them:

```cpp
// Analogy time:
class MemorySystem {
public:
    // 64-bit system = 8-lane highway
    // Can transport 8 bytes per trip
    char highway[8];  // 8 lanes wide
    
    // 32-bit system = 4-lane highway  
    // Can transport 4 bytes per trip
    char highway[4];  // 4 lanes wide
};
```

**The Rule**: The highway has fixed lanes. You can't send half a truck (half a word). You must fill all lanes, even if you're only carrying partial data.

### 2.3 Let's Prove This With Code

```cpp
#include <iostream>
#include <cstdint>

void demonstrateWordAccess() {
    // Let's see what happens with different data types
    
    std::cout << "=== Demonstrating Word-Sized Access ===\n";
    
    // Different data types have different sizes
    std::cout << "Size of char: " << sizeof(char) << " byte\n";
    std::cout << "Size of int: " << sizeof(int) << " bytes\n";
    std::cout << "Size of double: " << sizeof(double) << " bytes\n";
    
    // But the CPU's highway is fixed width!
    // On 64-bit system: highway width = 8 bytes
    // Let's show what happens with misalignment
}
```

**Homework**: Run this code. Notice that `double` is 8 bytes - exactly the highway width on 64-bit systems. This isn't a coincidence!

## Part 3: Alignment - The First Law of Memory

### 3.1 What is Alignment?

Alignment is a simple rule: **Data must start at addresses that are multiples of their size**.

```cpp
// Alignment rules:
char c;    // Can start anywhere (1-byte aligned)
int i;     // Must start at address divisible by 4 (4-byte aligned)  
double d;  // Must start at address divisible by 8 (8-byte aligned)

// Why? Let's see what happens if we break the rule...
```

### 3.2 The Cost of Misalignment

Let me show you with a concrete example:

```cpp
#include <iostream>
#include <chrono>

// Function to demonstrate misalignment penalty
void testAlignment() {
    const int SIZE = 1000000;
    
    // Create properly aligned array
    alignas(64) int aligned_array[SIZE];
    
    // Create misaligned array (shift by 1 byte)
    char buffer[SIZE * sizeof(int) + 1];
    int* misaligned_array = reinterpret_cast<int*>(&buffer[1]);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // Access aligned array
    for (int i = 0; i < SIZE; i++) {
        aligned_array[i] = i;
    }
    
    auto mid = std::chrono::high_resolution_clock::now();
    
    // Access misaligned array  
    for (int i = 0; i < SIZE; i++) {
        misaligned_array[i] = i;
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    
    auto aligned_time = std::chrono::duration_cast<std::chrono::microseconds>(mid - start);
    auto misaligned_time = std::chrono::duration_cast<std::chrono::microseconds>(end - mid);
    
    std::cout << "Aligned access time: " << aligned_time.count() << " microseconds\n";
    std::cout << "Misaligned access time: " << misaligned_time.count() << " microseconds\n";
    std::cout << "Penalty factor: " << (double)misaligned_time.count() / aligned_time.count() << "x slower!\n";
}
```

**Run this code!** You'll see misaligned access is 1.5-3x slower. On some CPUs (especially ARM), it might even crash!

### 3.3 Why Alignment Exists: The Hardware Explanation

Remember our highway analogy? Let's extend it:

Imagine you're shipping boxes (data) on trucks (words):

```cpp
class ShippingExample {
public:
    // Truck can carry 4 boxes at once (4-byte word)
    char truck[4];  // 4 boxes per truck
    
    // Perfect shipment: 4 boxes for 1 house
    void perfectShipment() {
        // House at address 0 gets boxes [0,1,2,3]
        // House at address 4 gets boxes [4,5,6,7]
        // One truck, one delivery - efficient!
    }
    
    // Problematic shipment: Boxes straddle houses
    void problematicShipment() {
        // House at address 1 needs boxes [1,2,3,4]
        // But box 1 is on truck with houses 0-3
        // Box 4 is on truck with houses 4-7
        // Need TWO trucks for ONE house!
    }
};
```

This is why alignment exists. It ensures each data item fits neatly in the CPU's "trucks" (words).

## Part 4: Padding - The Compiler's Secret Handshake

### 4.1 What is Padding?

Padding is **empty space** the compiler inserts between struct members to maintain alignment.

```cpp
// Let's see padding in action
struct BadLayout {
    char a;      // 1 byte
    int b;       // 4 bytes
    char c;      // 1 byte
};

struct GoodLayout {
    int b;       // 4 bytes
    char a;      // 1 byte
    char c;      // 1 byte
    // 2 bytes padding at end
};

void showSizes() {
    std::cout << "Size of BadLayout: " << sizeof(BadLayout) << " bytes\n";
    std::cout << "Size of GoodLayout: " << sizeof(GoodLayout) << " bytes\n";
    
    // Output will be:
    // Size of BadLayout: 12 bytes
    // Size of GoodLayout: 8 bytes
    // Same data, 33% less memory!
}
```

### 4.2 Let's Visualize the Memory Layout

```cpp
#include <iostream>

// Tool to visualize memory layout
template<typename T>
void visualizeMemory(const T& obj) {
    const unsigned char* bytes = reinterpret_cast<const unsigned char*>(&obj);
    
    std::cout << "Memory layout of " << typeid(T).name() << ":\n";
    std::cout << "Address  | Value | Meaning\n";
    std::cout << "---------|-------|--------\n";
    
    for (size_t i = 0; i < sizeof(T); i++) {
        std::cout << "0x" << std::hex << i << "     | ";
        
        if (bytes[i] == 0) {
            std::cout << "0x00  | PADDING\n";
        } else {
            std::cout << "0x" << std::hex << static_cast<int>(bytes[i]) << "  | DATA\n";
        }
    }
    std::cout << std::dec << "\n";
}

// Test structures
struct Test1 {
    char a;
    int b;
    char c;
};

struct Test2 {
    int b;
    char a;
    char c;
};

int main() {
    Test1 t1 = {'X', 42, 'Y'};
    Test2 t2 = {42, 'X', 'Y'};
    
    visualizeMemory(t1);
    visualizeMemory(t2);
    
    return 0;
}
```

### 4.3 The Golden Rule of Struct Layout

**Always order struct members from largest to smallest**

```cpp
// BAD - Lots of padding
struct BadOrder {
    char a;      // 1 byte
    double b;    // 8 bytes (needs 7 bytes padding before)
    char c;      // 1 byte (needs 7 bytes padding after)
    int d;       // 4 bytes
    // Total: 32 bytes!
};

// GOOD - Minimal padding  
struct GoodOrder {
    double b;    // 8 bytes
    int d;       // 4 bytes
    char a;      // 1 byte
    char c;      // 1 byte
    // 2 bytes padding at end
    // Total: 16 bytes (50% savings!)
};
```

**Exercise**: Calculate the padding in both structs. You'll see why ordering matters!

## Part 5: Cache Lines - Memory is Not Random Access

### 5.1 What is a Cache Line?

```cpp
// The shocking truth: When you access ANY byte,
// the CPU loads 64 BYTES around it!

class CacheLine {
public:
    // This is one cache line
    char data[64];  // 64 bytes loaded together
    
    // Accessing byte at position 30
    // Actually loads bytes 0-63!
};
```

### 5.2 Let's Measure Cache Line Effects

```cpp
#include <iostream>
#include <chrono>
#include <vector>

void demonstrateCacheLines() {
    const int SIZE = 1024 * 1024;  // 1MB
    std::vector<int> data(SIZE, 0);
    
    // Test 1: Access every element (good cache usage)
    auto start1 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; i++) {
        data[i] = i;
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // Test 2: Access every 16th element (bad cache usage)
    // Each access likely causes cache miss
    auto start2 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; i += 16) {
        data[i] = i;
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto time1 = std::chrono::duration_cast<std::chrono::microseconds>(end1 - start1);
    auto time2 = std::chrono::duration_cast<std::chrono::microseconds>(end2 - start2);
    
    std::cout << "Sequential access (good): " << time1.count() << " Œºs\n";
    std::cout << "Strided access (bad): " << time2.count() << " Œºs\n";
    std::cout << "Even though we do 16x LESS work, it's " 
              << (double)time2.count() / (time1.count() / 16) 
              << "x slower per access!\n";
}
```

### 5.3 Spatial Locality: The Key to Performance

Spatial locality means: **Data accessed together should be stored together**.

```cpp
// BAD: Poor spatial locality
class BadMatrix {
    float** data;  // Array of pointers
public:
    BadMatrix(int rows, int cols) {
        data = new float*[rows];
        for (int i = 0; i < rows; i++) {
            data[i] = new float[cols];
        }
    }
    // Accessing data[0][0] then data[1][0] jumps in memory!
};

// GOOD: Good spatial locality  
class GoodMatrix {
    float* data;  // Single contiguous block
    int rows, cols;
public:
    GoodMatrix(int r, int c) : rows(r), cols(c) {
        data = new float[rows * cols];
    }
    
    float& operator()(int row, int col) {
        return data[row * cols + col];
    }
    // Accessing (0,0) then (1,0) is adjacent in memory!
};
```

## Part 6: False Sharing - When Threads Step on Each Other's Toes

### 6.1 What is False Sharing?

False sharing occurs when **different threads modify different variables that happen to be in the same cache line**.

```cpp
// The Problem: Two counters in same cache line
struct SharedCounters {
    int counter1;  // Thread 1 updates this
    int counter2;  // Thread 2 updates this
    // Both in same 64-byte cache line!
};

void thread1(SharedCounters& counters) {
    for (int i = 0; i < 1000000; i++) {
        counters.counter1++;  // Invalidates entire cache line
    }
}

void thread2(SharedCounters& counters) {
    for (int i = 0; i < 1000000; i++) {
        counters.counter2++;  // Also invalidates same cache line!
    }
}
// Result: Cache line ping-pong between CPU cores!
```

### 6.2 Let's Measure False Sharing

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>

struct FalseSharingCounters {
    int counter1;
    int counter2;
};

struct FixedCounters {
    alignas(64) int counter1;  // Separate cache line
    alignas(64) int counter2;  // Separate cache line
};

void testFalseSharing() {
    const int ITERATIONS = 100000000;
    
    // Test with false sharing
    FalseSharingCounters bad;
    bad.counter1 = bad.counter2 = 0;
    
    auto start1 = std::chrono::high_resolution_clock::now();
    
    std::thread t1([&]() {
        for (int i = 0; i < ITERATIONS; i++) bad.counter1++;
    });
    
    std::thread t2([&]() {
        for (int i = 0; i < ITERATIONS; i++) bad.counter2++;
    });
    
    t1.join();
    t2.join();
    
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // Test with fixed alignment
    FixedCounters good;
    good.counter1 = good.counter2 = 0;
    
    auto start2 = std::chrono::high_resolution_clock::now();
    
    std::thread t3([&]() {
        for (int i = 0; i < ITERATIONS; i++) good.counter1++;
    });
    
    std::thread t4([&]() {
        for (int i = 0; i < ITERATIONS; i++) good.counter2++;
    });
    
    t3.join();
    t4.join();
    
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto time_bad = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto time_good = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "With false sharing: " << time_bad.count() << " ms\n";
    std::cout << "Without false sharing: " << time_good.count() << " ms\n";
    std::cout << "Performance improvement: " 
              << (double)time_bad.count() / time_good.count() 
              << "x faster!\n";
}
```

### 6.3 How to Fix False Sharing

```cpp
// Solution 1: Manual padding
struct PaddedCounter {
    int value;
    char padding[60];  // Pad to 64 bytes
};

// Solution 2: C++17 alignas
struct AlignedCounter {
    alignas(64) int value;  // Align to cache line boundary
};

// Solution 3: Thread-local storage
thread_local int counter;  // Each thread gets its own copy

// Solution 4: Separate allocations
std::unique_ptr<int[]> counters(new int[num_threads * 16]);
// Access as counters[thread_id * 16] to separate by cache lines
```

## Part 7: NUMA - Memory Has Geography

### 7.1 What is NUMA?

NUMA (Non-Uniform Memory Access) means: **Not all memory is equally far from all CPUs**.

```cpp
// In a 2-socket server:
class NUMASystem {
public:
    // Socket 0 has its own memory (fast access)
    Memory local_to_socket0;
    
    // Socket 1 has its own memory (fast access)
    Memory local_to_socket1;
    
    // But socket 0 accessing socket 1's memory is SLOW
    // 2-3x slower than local access!
};
```

### 7.2 Simulating NUMA Effects

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <numa.h>  // Linux NUMA library

void demonstrateNUMA() {
    // Only works on Linux with NUMA
    #ifdef __linux__
    if (numa_available() < 0) {
        std::cout << "NUMA not available on this system\n";
        return;
    }
    
    int num_nodes = numa_max_node() + 1;
    std::cout << "Number of NUMA nodes: " << num_nodes << "\n";
    
    const size_t SIZE = 1024 * 1024 * 100;  // 100MB
    
    // Test 1: Allocate on local node
    void* local_mem = numa_alloc_local(SIZE);
    
    // Test 2: Allocate on specific remote node
    int remote_node = (numa_node_of_cpu(0) + 1) % num_nodes;
    void* remote_mem = numa_alloc_onnode(SIZE, remote_node);
    
    // Time access to both
    volatile char* local = static_cast<char*>(local_mem);
    volatile char* remote = static_cast<char*>(remote_mem);
    
    auto start = std::chrono::high_resolution_clock::now();
    for (size_t i = 0; i < SIZE; i += 4096) {
        local[i] = i & 0xFF;
    }
    auto mid = std::chrono::high_resolution_clock::now();
    
    for (size_t i = 0; i < SIZE; i += 4096) {
        remote[i] = i & 0xFF;
    }
    auto end = std::chrono::high_resolution_clock::now();
    
    auto local_time = std::chrono::duration_cast<std::chrono::milliseconds>(mid - start);
    auto remote_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - mid);
    
    std::cout << "Local memory access: " << local_time.count() << " ms\n";
    std::cout << "Remote memory access: " << remote_time.count() << " ms\n";
    std::cout << "Remote is " << (double)remote_time.count() / local_time.count() 
              << "x slower!\n";
    
    numa_free(local_mem, SIZE);
    numa_free(remote_mem, SIZE);
    #endif
}
```

### 7.3 NUMA-Aware Programming Guidelines

```cpp
// Guideline 1: Allocate memory where it will be used
class NUMAWorker {
    void* local_memory;
    int numa_node;
    
public:
    NUMAWorker(int node) : numa_node(node) {
        // Allocate on this worker's NUMA node
        local_memory = numa_alloc_onnode(WORKER_MEMORY_SIZE, node);
        
        // Pin thread to CPUs on this node
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        // Add CPUs from this NUMA node
        bindToNUMANode(node);
    }
};

// Guideline 2: Use first-touch policy
void initializeMemoryNUMAware() {
    std::vector<std::thread> init_threads;
    
    for (int node = 0; node < num_numa_nodes; node++) {
        init_threads.emplace_back([node, this]() {
            // Pin thread to node
            bindToNUMANode(node);
            
            // Initialize memory region for this node
            // First touch binds memory to this node
            for (auto& elem : my_data_for_node(node)) {
                elem = 0;  // First touch!
            }
        });
    }
    
    for (auto& t : init_threads) t.join();
}
```

## Part 8: ABI - The Binary Peace Treaty

### 8.1 What is ABI?

ABI (Application Binary Interface) is: **The contract that allows binaries from different compilers to work together**.

```cpp
// Example of ABI differences:
struct ThisMightBreak {
    int x;
    char c;
    // GCC on Linux: sizeof = 8, alignof = 4
    // MSVC on Windows: sizeof = 8, alignof = 4  
    // Clang on macOS: sizeof = 8, alignof = 4
    // But what if padding differs?
};
```

### 8.2 ABI Issues in Real Porting

```cpp
// My actual Xcelium porting experience:

// ISSUE 1: Exception handling ABI
void problematicExceptionHandling() {
    // Linux/GCC: Itanium ABI
    // macOS/Clang: Itanium ABI (but different implementation)
    // Windows/MSVC: Structured Exception Handling (COMPLETELY DIFFERENT)
    
    try {
        throw std::runtime_error("test");
    } catch (const std::exception& e) {
        // This might not catch correctly across compiler boundaries!
    }
}

// ISSUE 2: Name mangling differences
extern "C" void simple_function();  // C linkage: _simple_function
void complex_function(int);         // C++ linkage: _Z15complex_functioni (GCC)
                                    // Different on other compilers!

// ISSUE 3: Standard library internals
std::string s = "hello";
// libstdc++ (GCC): Small string optimization with 15 chars local buffer
// libc++ (Clang): Small string optimization with 22 chars local buffer
// MSVC STL: Different small buffer size
```

### 8.3 How We Fixed ABI Issues in Xcelium

```cpp
// Solution 1: Hide implementation details (PIMPL idiom)
class PublicInterface {
private:
    class Impl;  // Forward declaration
    std::unique_ptr<Impl> pimpl;  // Opaque pointer
    
public:
    PublicInterface();
    ~PublicInterface();
    void publicMethod();  // Implemented in .cpp file
};

// Solution 2: Use C linkage for cross-compiler compatibility
extern "C" {
    // These functions have simple, stable names
    void* create_simulator();
    void destroy_simulator(void*);
    int run_simulation(void*, const char* config);
}

// Solution 3: Version your interfaces
struct SimulatorAPI_v1 {
    int version;  // Always first member
    void* (*create)();
    void (*destroy)(void*);
    // ... v1 functions
};

struct SimulatorAPI_v2 {
    int version;  // Always first member  
    void* (*create)();
    void (*destroy)(void*);
    // ... v2 functions with new features
    int (*new_feature)(void*);
};

// Solution 4: Recompile everything with same compiler
void rebuildThirdPartyLibraries() {
    // Had to recompile:
    // - Boost (massive!)
    // - OpenSSL  
    // - Protocol Buffers
    // - Various numerics libraries
    
    // Command used:
    // ./configure CC=clang CXX=clang++ CXXFLAGS="-std=c++14"
    // make -j8
}
```

## Part 9: Xcelium Case Study - Theory to Production

### 9.1 Real Optimization: Signal Storage

```cpp
// BEFORE: Memory-inefficient signal storage
class OriginalSignalStorage {
    struct Signal {
        double value;           // 8 bytes
        uint64_t timestamp;     // 8 bytes
        int signal_id;          // 4 bytes
        char signal_type;       // 1 byte
        bool is_active;         // 1 byte
        // 2 bytes padding
        // Total: 24 bytes per signal
    };
    
    std::vector<Signal> signals;  // AoS pattern
    
public:
    // Problem: Accessing values causes cache misses
    // Only 2-3 values per cache line!
};

// AFTER: Cache-optimized signal storage  
class OptimizedSignalStorage {
    // Structure of Arrays (SoA) pattern
    struct SignalData {
        std::vector<double> values;      // Hot data: frequently accessed
        std::vector<uint64_t> timestamps; // Warm data: occasionally accessed
        std::vector<int> signal_ids;      // Cold data: rarely accessed
        std::vector<char> signal_types;   // Cold data
        std::vector<bool> active_flags;   // Cold data
        
        // Each vector can be cache-aligned
    };
    
    alignas(64) SignalData data;
    
public:
    // Now processing values: excellent cache locality!
    // 16 values per cache line (vs 2-3 before)
    
    void processAllValues() {
        for (size_t i = 0; i < data.values.size(); i++) {
            data.values[i] *= 1.1;  // All values contiguous in memory!
        }
    }
};
```

### 9.2 Performance Results

```cpp
void showXceliumPerformanceGains() {
    std::cout << "=== Xcelium Multicore Optimization Results ===\n";
    
    std::cout << "Memory Layout Optimizations:\n";
    std::cout << "  - Struct reordering: 15% memory reduction\n";
    std::cout << "  - AoS to SoA conversion: 40% better cache utilization\n";
    std::cout << "  - Cache line alignment: 70% reduction in false sharing\n";
    
    std::cout << "\nNUMA Optimizations:\n";
    std::cout << "  - NUMA-aware allocation: 60% reduction in memory latency\n";
    std::cout << "  - Thread pinning: 30% better core utilization\n";
    
    std::cout << "\nOverall Simulation Performance:\n";
    std::cout << "  - Single-core: 1.8x speedup\n";
    std::cout << "  - 16-core scaling: From 4x to 12x linear speedup\n";
    std::cout << "  - Memory bandwidth: Reduced from 45 GB/s to 28 GB/s\n";
    std::cout << "  - Cache miss rate: Reduced from 12.3% to 4.7%\n";
}
```

### 9.3 The Complete Optimization Checklist

```cpp
class MemoryOptimizationChecklist {
public:
    static void checkYourCode() {
        // 1. Alignment Check
        checkAlignment();
        
        // 2. Padding Check  
        minimizePadding();
        
        // 3. Cache Line Awareness
        avoidFalseSharing();
        
        // 4. Spatial Locality
        optimizeAccessPatterns();
        
        // 5. NUMA Awareness
        allocateLocally();
        
        // 6. ABI Stability
        maintainBinaryCompatibility();
    }
    
private:
    static void checkAlignment() {
        // Use alignas for performance-critical data
        alignas(64) CriticalData data;
        
        // Check alignment with alignof
        static_assert(alignof(CriticalData) >= 64, 
                     "Critical data not properly aligned!");
    }
    
    static void minimizePadding() {
        // Rule: Largest members first
        struct Optimized {
            double d;  // 8 bytes
            long l;    // 8 bytes  
            int i;     // 4 bytes
            short s;   // 2 bytes
            char c;    // 1 byte
            // 1 byte padding
        };
    }
    
    static void avoidFalseSharing() {
        // Separate thread data by cache lines
        struct alignas(64) ThreadLocalData {
            int local_counter;
            char padding[64 - sizeof(int)];
        };
    }
};
```

## Summary: What You've Learned Today

Congratulations! You've just completed a PhD-level journey through C++ memory systems. Let's recap:

### Key Takeaways:

1. **Memory is physical**: It's not abstract - it's billions of switches arranged in specific patterns.

2. **Alignment is non-negotiable**: CPUs are built for aligned access. Fight it and you lose performance.

3. **Cache lines rule everything**: 64-byte blocks determine your performance more than your algorithm.

4. **False sharing is silent**: Your multicore code might be slower than single-core due to cache contention.

5. **Memory has distance**: NUMA systems make locality a first-class concern.

6. **ABI is the peace treaty**: Different compilers need rules to interoperate.

7. **Data layout beats algorithm tuning**: Often, rearranging memory gives bigger gains than optimizing loops.

### Your Homework:

1. Run all the code examples in this guide
2. Profile your own code with `perf` or `valgrind`
3. Try the Xcelium-style optimizations on a small project
4. Practice explaining these concepts to a rubber duck

### Next Steps:

Tomorrow, we'll dive into **Virtual Functions, vtables, and C++ Object Model**. You'll understand why virtual functions have a cost, how vtables work at the assembly level, and how to optimize polymorphic code for EDA tools.

Remember: Understanding memory isn't just for interviews. It's what separates senior engineers from architects. When you can predict how your code will behave at the hardware level, you've reached a new level of engineering mastery.

---

**Pro Tip for Interviews**: When asked about memory, start with "Let me explain how CPUs actually access memory..." This shows you understand the hardware reality, not just C++ syntax. You'll immediately stand out from 95% of other candidates.

Happy coding! üöÄ
=== FILE: src/content/learn/virtual-base-classes.mdx ===

=== FILE: src/content/learn/sizeof-alignof-ebo.mdx ===

=== FILE: src/content/learn/memory-layout-padding.mdx ===
---
title: "C++ Object Layout in Memory"
description: "Understand how objects are laid out in memory from a systems perspective."
access: "free"
---

# C++ Object Layout in Memory

This is **normal text**.
If this looks like code, something is wrong ‚ùå.

C++ objects are not abstract ‚Äî they are **bytes laid out in memory**.

---

## Simple Example

Here is an inline code example: `sizeof(int)`
This should look inline, **not like a block**.

---

## Basic C++ Struct

```cpp
struct Point {
    int x;
    int y;
};
```


=== FILE: src/content/learn/multiple-inheritance-layout.mdx ===

=== FILE: src/content/learn/vtables-internals.mdx ===
---
title: "Virtual Tables (vtables) ‚Äî Internals"
slug: "vtables-internals"
access: "premium"
description: "How vtables are laid out, dispatch works, and what changes break ABI."
---

=== FILE: src/content/learn/60-day-cpp-interview/lesson-1.mdx ===
# Day 1: C++ Memory Layout - From Zero to PhD Level

## Table of Contents
- [Introduction: Why Memory Layout Matters](#introduction-why-memory-layout-matters)
- [Part 1: What is Memory? Let's Start From Atoms](#part-1-what-is-memory-lets-start-from-atoms)
- [Part 2: How CPUs Read Memory - The Hardware Reality](#part-2-how-cpus-read-memory---the-hardware-reality)
- [Part 3: Alignment - The First Law of Memory](#part-3-alignment---the-first-law-of-memory)
- [Part 4: Padding - The Compiler's Secret Handshake](#part-4-padding---the-compilers-secret-handshake)
- [Part 5: Cache Lines - Memory is Not Random Access](#part-5-cache-lines---memory-is-not-random-access)
- [Part 6: False Sharing - When Threads Step on Each Other's Toes](#part-6-false-sharing---when-threads-step-on-each-others-toes)
- [Part 7: NUMA - Memory Has Geography](#part-7-numa---memory-has-geography)
- [Part 8: ABI - The Binary Peace Treaty](#part-8-abi---the-binary-peace-treaty)
- [Part 9: Xcelium Case Study - Theory to Production](#part-9-xcelium-case-study---theory-to-production)

## Introduction: Why Memory Layout Matters

Welcome to Day 1 of our deep dive into C++ memory systems! Today, we're going to start from the absolute basics and build up to PhD-level understanding. 

**The Big Idea**: Your C++ code isn't just logic - it's a blueprint for how electricity should flow through silicon. Understanding memory layout is understanding that blueprint.

## Part 1: What is Memory? Let's Start From Atoms

### 1.1 Memory is Just Switches

```cpp
// Let's start with the smallest unit: a bit
bool bit = true;  // This is either 1 or 0
```

At the hardware level, memory is made of billions of tiny switches (transistors). Each switch can be ON (1) or OFF (0). That's all memory is - a giant sea of switches.

### 1.2 Bytes: Groups of 8 Switches

```cpp
char byte = 'A';  // Actually stores: 01000001
```

A **byte** is 8 bits (8 switches) together. Why 8? Historical reasons, but now it's the universal standard.

### 1.3 Visualizing Memory Addresses

Imagine memory as a giant spreadsheet:

```cpp
// Memory is like this spreadsheet:
Address  | Value (binary)   | Value (decimal)
0x1000   | 01000001         | 65 ('A')
0x1001   | 01000010         | 66 ('B')
0x1002   | 01000011         | 67 ('C')
// ... and so on for billions of rows
```

Every byte has an **address** - a unique number telling the CPU where to find it. Think of it like house numbers on a very long street.

**Key Insight**: Memory isn't "smart" - it doesn't know what data it stores. It's just switches that can be flipped. The CPU interprets these patterns.

## Part 2: How CPUs Read Memory - The Hardware Reality

### 2.1 CPUs Don't Read Bytes One by One

This is the most important misconception to correct:

```cpp
// What you THINK happens:
int x = 42;  // CPU reads 4 bytes individually
// Byte 1 ‚Üí Byte 2 ‚Üí Byte 3 ‚Üí Byte 4

// What ACTUALLY happens (on 64-bit CPU):
int x = 42;  // CPU tries to read 8 bytes at once!
// Reads address 0-7 in one operation
```

Modern CPUs are built to read **word-sized chunks** all at once. A "word" is typically:
- 4 bytes on 32-bit systems
- 8 bytes on 64-bit systems

### 2.2 The Data Bus: Memory's Highway

Think of the CPU as a factory and memory as a warehouse. The data bus is the highway between them:

```cpp
// Analogy time:
class MemorySystem {
public:
    // 64-bit system = 8-lane highway
    // Can transport 8 bytes per trip
    char highway[8];  // 8 lanes wide
    
    // 32-bit system = 4-lane highway  
    // Can transport 4 bytes per trip
    char highway[4];  // 4 lanes wide
};
```

**The Rule**: The highway has fixed lanes. You can't send half a truck (half a word). You must fill all lanes, even if you're only carrying partial data.

### 2.3 Let's Prove This With Code

```cpp
#include <iostream>
#include <cstdint>

void demonstrateWordAccess() {
    // Let's see what happens with different data types
    
    std::cout << "=== Demonstrating Word-Sized Access ===\n";
    
    // Different data types have different sizes
    std::cout << "Size of char: " << sizeof(char) << " byte\n";
    std::cout << "Size of int: " << sizeof(int) << " bytes\n";
    std::cout << "Size of double: " << sizeof(double) << " bytes\n";
    
    // But the CPU's highway is fixed width!
    // On 64-bit system: highway width = 8 bytes
    // Let's show what happens with misalignment
}
```

**Homework**: Run this code. Notice that `double` is 8 bytes - exactly the highway width on 64-bit systems. This isn't a coincidence!

## Part 3: Alignment - The First Law of Memory

### 3.1 What is Alignment?

Alignment is a simple rule: **Data must start at addresses that are multiples of their size**.

```cpp
// Alignment rules:
char c;    // Can start anywhere (1-byte aligned)
int i;     // Must start at address divisible by 4 (4-byte aligned)  
double d;  // Must start at address divisible by 8 (8-byte aligned)

// Why? Let's see what happens if we break the rule...
```

### 3.2 The Cost of Misalignment

Let me show you with a concrete example:

```cpp
#include <iostream>
#include <chrono>

// Function to demonstrate misalignment penalty
void testAlignment() {
    const int SIZE = 1000000;
    
    // Create properly aligned array
    alignas(64) int aligned_array[SIZE];
    
    // Create misaligned array (shift by 1 byte)
    char buffer[SIZE * sizeof(int) + 1];
    int* misaligned_array = reinterpret_cast<int*>(&buffer[1]);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    // Access aligned array
    for (int i = 0; i < SIZE; i++) {
        aligned_array[i] = i;
    }
    
    auto mid = std::chrono::high_resolution_clock::now();
    
    // Access misaligned array  
    for (int i = 0; i < SIZE; i++) {
        misaligned_array[i] = i;
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    
    auto aligned_time = std::chrono::duration_cast<std::chrono::microseconds>(mid - start);
    auto misaligned_time = std::chrono::duration_cast<std::chrono::microseconds>(end - mid);
    
    std::cout << "Aligned access time: " << aligned_time.count() << " microseconds\n";
    std::cout << "Misaligned access time: " << misaligned_time.count() << " microseconds\n";
    std::cout << "Penalty factor: " << (double)misaligned_time.count() / aligned_time.count() << "x slower!\n";
}
```

**Run this code!** You'll see misaligned access is 1.5-3x slower. On some CPUs (especially ARM), it might even crash!

### 3.3 Why Alignment Exists: The Hardware Explanation

Remember our highway analogy? Let's extend it:

Imagine you're shipping boxes (data) on trucks (words):

```cpp
class ShippingExample {
public:
    // Truck can carry 4 boxes at once (4-byte word)
    char truck[4];  // 4 boxes per truck
    
    // Perfect shipment: 4 boxes for 1 house
    void perfectShipment() {
        // House at address 0 gets boxes [0,1,2,3]
        // House at address 4 gets boxes [4,5,6,7]
        // One truck, one delivery - efficient!
    }
    
    // Problematic shipment: Boxes straddle houses
    void problematicShipment() {
        // House at address 1 needs boxes [1,2,3,4]
        // But box 1 is on truck with houses 0-3
        // Box 4 is on truck with houses 4-7
        // Need TWO trucks for ONE house!
    }
};
```

This is why alignment exists. It ensures each data item fits neatly in the CPU's "trucks" (words).

## Part 4: Padding - The Compiler's Secret Handshake

### 4.1 What is Padding?

Padding is **empty space** the compiler inserts between struct members to maintain alignment.

```cpp
// Let's see padding in action
struct BadLayout {
    char a;      // 1 byte
    int b;       // 4 bytes
    char c;      // 1 byte
};

struct GoodLayout {
    int b;       // 4 bytes
    char a;      // 1 byte
    char c;      // 1 byte
    // 2 bytes padding at end
};

void showSizes() {
    std::cout << "Size of BadLayout: " << sizeof(BadLayout) << " bytes\n";
    std::cout << "Size of GoodLayout: " << sizeof(GoodLayout) << " bytes\n";
    
    // Output will be:
    // Size of BadLayout: 12 bytes
    // Size of GoodLayout: 8 bytes
    // Same data, 33% less memory!
}
```

### 4.2 Let's Visualize the Memory Layout

```cpp
#include <iostream>

// Tool to visualize memory layout
template<typename T>
void visualizeMemory(const T& obj) {
    const unsigned char* bytes = reinterpret_cast<const unsigned char*>(&obj);
    
    std::cout << "Memory layout of " << typeid(T).name() << ":\n";
    std::cout << "Address  | Value | Meaning\n";
    std::cout << "---------|-------|--------\n";
    
    for (size_t i = 0; i < sizeof(T); i++) {
        std::cout << "0x" << std::hex << i << "     | ";
        
        if (bytes[i] == 0) {
            std::cout << "0x00  | PADDING\n";
        } else {
            std::cout << "0x" << std::hex << static_cast<int>(bytes[i]) << "  | DATA\n";
        }
    }
    std::cout << std::dec << "\n";
}

// Test structures
struct Test1 {
    char a;
    int b;
    char c;
};

struct Test2 {
    int b;
    char a;
    char c;
};

int main() {
    Test1 t1 = {'X', 42, 'Y'};
    Test2 t2 = {42, 'X', 'Y'};
    
    visualizeMemory(t1);
    visualizeMemory(t2);
    
    return 0;
}
```

### 4.3 The Golden Rule of Struct Layout

**Always order struct members from largest to smallest**

```cpp
// BAD - Lots of padding
struct BadOrder {
    char a;      // 1 byte
    double b;    // 8 bytes (needs 7 bytes padding before)
    char c;      // 1 byte (needs 7 bytes padding after)
    int d;       // 4 bytes
    // Total: 32 bytes!
};

// GOOD - Minimal padding  
struct GoodOrder {
    double b;    // 8 bytes
    int d;       // 4 bytes
    char a;      // 1 byte
    char c;      // 1 byte
    // 2 bytes padding at end
    // Total: 16 bytes (50% savings!)
};
```

**Exercise**: Calculate the padding in both structs. You'll see why ordering matters!

## Part 5: Cache Lines - Memory is Not Random Access

### 5.1 What is a Cache Line?

```cpp
// The shocking truth: When you access ANY byte,
// the CPU loads 64 BYTES around it!

class CacheLine {
public:
    // This is one cache line
    char data[64];  // 64 bytes loaded together
    
    // Accessing byte at position 30
    // Actually loads bytes 0-63!
};
```

### 5.2 Let's Measure Cache Line Effects

```cpp
#include <iostream>
#include <chrono>
#include <vector>

void demonstrateCacheLines() {
    const int SIZE = 1024 * 1024;  // 1MB
    std::vector<int> data(SIZE, 0);
    
    // Test 1: Access every element (good cache usage)
    auto start1 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; i++) {
        data[i] = i;
    }
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // Test 2: Access every 16th element (bad cache usage)
    // Each access likely causes cache miss
    auto start2 = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < SIZE; i += 16) {
        data[i] = i;
    }
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto time1 = std::chrono::duration_cast<std::chrono::microseconds>(end1 - start1);
    auto time2 = std::chrono::duration_cast<std::chrono::microseconds>(end2 - start2);
    
    std::cout << "Sequential access (good): " << time1.count() << " Œºs\n";
    std::cout << "Strided access (bad): " << time2.count() << " Œºs\n";
    std::cout << "Even though we do 16x LESS work, it's " 
              << (double)time2.count() / (time1.count() / 16) 
              << "x slower per access!\n";
}
```

### 5.3 Spatial Locality: The Key to Performance

Spatial locality means: **Data accessed together should be stored together**.

```cpp
// BAD: Poor spatial locality
class BadMatrix {
    float** data;  // Array of pointers
public:
    BadMatrix(int rows, int cols) {
        data = new float*[rows];
        for (int i = 0; i < rows; i++) {
            data[i] = new float[cols];
        }
    }
    // Accessing data[0][0] then data[1][0] jumps in memory!
};

// GOOD: Good spatial locality  
class GoodMatrix {
    float* data;  // Single contiguous block
    int rows, cols;
public:
    GoodMatrix(int r, int c) : rows(r), cols(c) {
        data = new float[rows * cols];
    }
    
    float& operator()(int row, int col) {
        return data[row * cols + col];
    }
    // Accessing (0,0) then (1,0) is adjacent in memory!
};
```

## Part 6: False Sharing - When Threads Step on Each Other's Toes

### 6.1 What is False Sharing?

False sharing occurs when **different threads modify different variables that happen to be in the same cache line**.

```cpp
// The Problem: Two counters in same cache line
struct SharedCounters {
    int counter1;  // Thread 1 updates this
    int counter2;  // Thread 2 updates this
    // Both in same 64-byte cache line!
};

void thread1(SharedCounters& counters) {
    for (int i = 0; i < 1000000; i++) {
        counters.counter1++;  // Invalidates entire cache line
    }
}

void thread2(SharedCounters& counters) {
    for (int i = 0; i < 1000000; i++) {
        counters.counter2++;  // Also invalidates same cache line!
    }
}
// Result: Cache line ping-pong between CPU cores!
```

### 6.2 Let's Measure False Sharing

```cpp
#include <iostream>
#include <thread>
#include <chrono>
#include <vector>

struct FalseSharingCounters {
    int counter1;
    int counter2;
};

struct FixedCounters {
    alignas(64) int counter1;  // Separate cache line
    alignas(64) int counter2;  // Separate cache line
};

void testFalseSharing() {
    const int ITERATIONS = 100000000;
    
    // Test with false sharing
    FalseSharingCounters bad;
    bad.counter1 = bad.counter2 = 0;
    
    auto start1 = std::chrono::high_resolution_clock::now();
    
    std::thread t1([&]() {
        for (int i = 0; i < ITERATIONS; i++) bad.counter1++;
    });
    
    std::thread t2([&]() {
        for (int i = 0; i < ITERATIONS; i++) bad.counter2++;
    });
    
    t1.join();
    t2.join();
    
    auto end1 = std::chrono::high_resolution_clock::now();
    
    // Test with fixed alignment
    FixedCounters good;
    good.counter1 = good.counter2 = 0;
    
    auto start2 = std::chrono::high_resolution_clock::now();
    
    std::thread t3([&]() {
        for (int i = 0; i < ITERATIONS; i++) good.counter1++;
    });
    
    std::thread t4([&]() {
        for (int i = 0; i < ITERATIONS; i++) good.counter2++;
    });
    
    t3.join();
    t4.join();
    
    auto end2 = std::chrono::high_resolution_clock::now();
    
    auto time_bad = std::chrono::duration_cast<std::chrono::milliseconds>(end1 - start1);
    auto time_good = std::chrono::duration_cast<std::chrono::milliseconds>(end2 - start2);
    
    std::cout << "With false sharing: " << time_bad.count() << " ms\n";
    std::cout << "Without false sharing: " << time_good.count() << " ms\n";
    std::cout << "Performance improvement: " 
              << (double)time_bad.count() / time_good.count() 
              << "x faster!\n";
}
```

### 6.3 How to Fix False Sharing

```cpp
// Solution 1: Manual padding
struct PaddedCounter {
    int value;
    char padding[60];  // Pad to 64 bytes
};

// Solution 2: C++17 alignas
struct AlignedCounter {
    alignas(64) int value;  // Align to cache line boundary
};

// Solution 3: Thread-local storage
thread_local int counter;  // Each thread gets its own copy

// Solution 4: Separate allocations
std::unique_ptr<int[]> counters(new int[num_threads * 16]);
// Access as counters[thread_id * 16] to separate by cache lines
```

## Part 7: NUMA - Memory Has Geography

### 7.1 What is NUMA?

NUMA (Non-Uniform Memory Access) means: **Not all memory is equally far from all CPUs**.

```cpp
// In a 2-socket server:
class NUMASystem {
public:
    // Socket 0 has its own memory (fast access)
    Memory local_to_socket0;
    
    // Socket 1 has its own memory (fast access)
    Memory local_to_socket1;
    
    // But socket 0 accessing socket 1's memory is SLOW
    // 2-3x slower than local access!
};
```

### 7.2 Simulating NUMA Effects

```cpp
#include <iostream>
#include <thread>
#include <vector>
#include <numa.h>  // Linux NUMA library

void demonstrateNUMA() {
    // Only works on Linux with NUMA
    #ifdef __linux__
    if (numa_available() < 0) {
        std::cout << "NUMA not available on this system\n";
        return;
    }
    
    int num_nodes = numa_max_node() + 1;
    std::cout << "Number of NUMA nodes: " << num_nodes << "\n";
    
    const size_t SIZE = 1024 * 1024 * 100;  // 100MB
    
    // Test 1: Allocate on local node
    void* local_mem = numa_alloc_local(SIZE);
    
    // Test 2: Allocate on specific remote node
    int remote_node = (numa_node_of_cpu(0) + 1) % num_nodes;
    void* remote_mem = numa_alloc_onnode(SIZE, remote_node);
    
    // Time access to both
    volatile char* local = static_cast<char*>(local_mem);
    volatile char* remote = static_cast<char*>(remote_mem);
    
    auto start = std::chrono::high_resolution_clock::now();
    for (size_t i = 0; i < SIZE; i += 4096) {
        local[i] = i & 0xFF;
    }
    auto mid = std::chrono::high_resolution_clock::now();
    
    for (size_t i = 0; i < SIZE; i += 4096) {
        remote[i] = i & 0xFF;
    }
    auto end = std::chrono::high_resolution_clock::now();
    
    auto local_time = std::chrono::duration_cast<std::chrono::milliseconds>(mid - start);
    auto remote_time = std::chrono::duration_cast<std::chrono::milliseconds>(end - mid);
    
    std::cout << "Local memory access: " << local_time.count() << " ms\n";
    std::cout << "Remote memory access: " << remote_time.count() << " ms\n";
    std::cout << "Remote is " << (double)remote_time.count() / local_time.count() 
              << "x slower!\n";
    
    numa_free(local_mem, SIZE);
    numa_free(remote_mem, SIZE);
    #endif
}
```

### 7.3 NUMA-Aware Programming Guidelines

```cpp
// Guideline 1: Allocate memory where it will be used
class NUMAWorker {
    void* local_memory;
    int numa_node;
    
public:
    NUMAWorker(int node) : numa_node(node) {
        // Allocate on this worker's NUMA node
        local_memory = numa_alloc_onnode(WORKER_MEMORY_SIZE, node);
        
        // Pin thread to CPUs on this node
        cpu_set_t cpuset;
        CPU_ZERO(&cpuset);
        // Add CPUs from this NUMA node
        bindToNUMANode(node);
    }
};

// Guideline 2: Use first-touch policy
void initializeMemoryNUMAware() {
    std::vector<std::thread> init_threads;
    
    for (int node = 0; node < num_numa_nodes; node++) {
        init_threads.emplace_back([node, this]() {
            // Pin thread to node
            bindToNUMANode(node);
            
            // Initialize memory region for this node
            // First touch binds memory to this node
            for (auto& elem : my_data_for_node(node)) {
                elem = 0;  // First touch!
            }
        });
    }
    
    for (auto& t : init_threads) t.join();
}
```

## Part 8: ABI - The Binary Peace Treaty

### 8.1 What is ABI?

ABI (Application Binary Interface) is: **The contract that allows binaries from different compilers to work together**.

```cpp
// Example of ABI differences:
struct ThisMightBreak {
    int x;
    char c;
    // GCC on Linux: sizeof = 8, alignof = 4
    // MSVC on Windows: sizeof = 8, alignof = 4  
    // Clang on macOS: sizeof = 8, alignof = 4
    // But what if padding differs?
};
```

### 8.2 ABI Issues in Real Porting

```cpp
// My actual Xcelium porting experience:

// ISSUE 1: Exception handling ABI
void problematicExceptionHandling() {
    // Linux/GCC: Itanium ABI
    // macOS/Clang: Itanium ABI (but different implementation)
    // Windows/MSVC: Structured Exception Handling (COMPLETELY DIFFERENT)
    
    try {
        throw std::runtime_error("test");
    } catch (const std::exception& e) {
        // This might not catch correctly across compiler boundaries!
    }
}

// ISSUE 2: Name mangling differences
extern "C" void simple_function();  // C linkage: _simple_function
void complex_function(int);         // C++ linkage: _Z15complex_functioni (GCC)
                                    // Different on other compilers!

// ISSUE 3: Standard library internals
std::string s = "hello";
// libstdc++ (GCC): Small string optimization with 15 chars local buffer
// libc++ (Clang): Small string optimization with 22 chars local buffer
// MSVC STL: Different small buffer size
```

### 8.3 How We Fixed ABI Issues in Xcelium

```cpp
// Solution 1: Hide implementation details (PIMPL idiom)
class PublicInterface {
private:
    class Impl;  // Forward declaration
    std::unique_ptr<Impl> pimpl;  // Opaque pointer
    
public:
    PublicInterface();
    ~PublicInterface();
    void publicMethod();  // Implemented in .cpp file
};

// Solution 2: Use C linkage for cross-compiler compatibility
extern "C" {
    // These functions have simple, stable names
    void* create_simulator();
    void destroy_simulator(void*);
    int run_simulation(void*, const char* config);
}

// Solution 3: Version your interfaces
struct SimulatorAPI_v1 {
    int version;  // Always first member
    void* (*create)();
    void (*destroy)(void*);
    // ... v1 functions
};

struct SimulatorAPI_v2 {
    int version;  // Always first member  
    void* (*create)();
    void (*destroy)(void*);
    // ... v2 functions with new features
    int (*new_feature)(void*);
};

// Solution 4: Recompile everything with same compiler
void rebuildThirdPartyLibraries() {
    // Had to recompile:
    // - Boost (massive!)
    // - OpenSSL  
    // - Protocol Buffers
    // - Various numerics libraries
    
    // Command used:
    // ./configure CC=clang CXX=clang++ CXXFLAGS="-std=c++14"
    // make -j8
}
```

## Part 9: Xcelium Case Study - Theory to Production

### 9.1 Real Optimization: Signal Storage

```cpp
// BEFORE: Memory-inefficient signal storage
class OriginalSignalStorage {
    struct Signal {
        double value;           // 8 bytes
        uint64_t timestamp;     // 8 bytes
        int signal_id;          // 4 bytes
        char signal_type;       // 1 byte
        bool is_active;         // 1 byte
        // 2 bytes padding
        // Total: 24 bytes per signal
    };
    
    std::vector<Signal> signals;  // AoS pattern
    
public:
    // Problem: Accessing values causes cache misses
    // Only 2-3 values per cache line!
};

// AFTER: Cache-optimized signal storage  
class OptimizedSignalStorage {
    // Structure of Arrays (SoA) pattern
    struct SignalData {
        std::vector<double> values;      // Hot data: frequently accessed
        std::vector<uint64_t> timestamps; // Warm data: occasionally accessed
        std::vector<int> signal_ids;      // Cold data: rarely accessed
        std::vector<char> signal_types;   // Cold data
        std::vector<bool> active_flags;   // Cold data
        
        // Each vector can be cache-aligned
    };
    
    alignas(64) SignalData data;
    
public:
    // Now processing values: excellent cache locality!
    // 16 values per cache line (vs 2-3 before)
    
    void processAllValues() {
        for (size_t i = 0; i < data.values.size(); i++) {
            data.values[i] *= 1.1;  // All values contiguous in memory!
        }
    }
};
```

### 9.2 Performance Results

```cpp
void showXceliumPerformanceGains() {
    std::cout << "=== Xcelium Multicore Optimization Results ===\n";
    
    std::cout << "Memory Layout Optimizations:\n";
    std::cout << "  - Struct reordering: 15% memory reduction\n";
    std::cout << "  - AoS to SoA conversion: 40% better cache utilization\n";
    std::cout << "  - Cache line alignment: 70% reduction in false sharing\n";
    
    std::cout << "\nNUMA Optimizations:\n";
    std::cout << "  - NUMA-aware allocation: 60% reduction in memory latency\n";
    std::cout << "  - Thread pinning: 30% better core utilization\n";
    
    std::cout << "\nOverall Simulation Performance:\n";
    std::cout << "  - Single-core: 1.8x speedup\n";
    std::cout << "  - 16-core scaling: From 4x to 12x linear speedup\n";
    std::cout << "  - Memory bandwidth: Reduced from 45 GB/s to 28 GB/s\n";
    std::cout << "  - Cache miss rate: Reduced from 12.3% to 4.7%\n";
}
```

### 9.3 The Complete Optimization Checklist

```cpp
class MemoryOptimizationChecklist {
public:
    static void checkYourCode() {
        // 1. Alignment Check
        checkAlignment();
        
        // 2. Padding Check  
        minimizePadding();
        
        // 3. Cache Line Awareness
        avoidFalseSharing();
        
        // 4. Spatial Locality
        optimizeAccessPatterns();
        
        // 5. NUMA Awareness
        allocateLocally();
        
        // 6. ABI Stability
        maintainBinaryCompatibility();
    }
    
private:
    static void checkAlignment() {
        // Use alignas for performance-critical data
        alignas(64) CriticalData data;
        
        // Check alignment with alignof
        static_assert(alignof(CriticalData) >= 64, 
                     "Critical data not properly aligned!");
    }
    
    static void minimizePadding() {
        // Rule: Largest members first
        struct Optimized {
            double d;  // 8 bytes
            long l;    // 8 bytes  
            int i;     // 4 bytes
            short s;   // 2 bytes
            char c;    // 1 byte
            // 1 byte padding
        };
    }
    
    static void avoidFalseSharing() {
        // Separate thread data by cache lines
        struct alignas(64) ThreadLocalData {
            int local_counter;
            char padding[64 - sizeof(int)];
        };
    }
};
```

## Summary: What You've Learned Today

Congratulations! You've just completed a PhD-level journey through C++ memory systems. Let's recap:

### Key Takeaways:

1. **Memory is physical**: It's not abstract - it's billions of switches arranged in specific patterns.

2. **Alignment is non-negotiable**: CPUs are built for aligned access. Fight it and you lose performance.

3. **Cache lines rule everything**: 64-byte blocks determine your performance more than your algorithm.

4. **False sharing is silent**: Your multicore code might be slower than single-core due to cache contention.

5. **Memory has distance**: NUMA systems make locality a first-class concern.

6. **ABI is the peace treaty**: Different compilers need rules to interoperate.

7. **Data layout beats algorithm tuning**: Often, rearranging memory gives bigger gains than optimizing loops.

### Your Homework:

1. Run all the code examples in this guide
2. Profile your own code with `perf` or `valgrind`
3. Try the Xcelium-style optimizations on a small project
4. Practice explaining these concepts to a rubber duck

### Next Steps:

Tomorrow, we'll dive into **Virtual Functions, vtables, and C++ Object Model**. You'll understand why virtual functions have a cost, how vtables work at the assembly level, and how to optimize polymorphic code for EDA tools.

Remember: Understanding memory isn't just for interviews. It's what separates senior engineers from architects. When you can predict how your code will behave at the hardware level, you've reached a new level of engineering mastery.

---

**Pro Tip for Interviews**: When asked about memory, start with "Let me explain how CPUs actually access memory..." This shows you understand the hardware reality, not just C++ syntax. You'll immediately stand out from 95% of other candidates.

Happy coding! üöÄ
=== FILE: src/content/tracks/mastering-cpp-templates.mdx ===
---
title: "Mastering C++ Templates & Metaprogramming"
slug: "mastering-cpp-templates"
access: "premium"
live: false
price: 399
duration: "30 days"
level: "Advanced"
description: "From template basics to TMP, concepts, and interview-grade mastery. Learn template instantiation, SFINAE, concepts, and compile-time computation patterns."
lessonCount: 80
tags: ["Templates", "Metaprogramming", "Concepts", "SFINAE", "Compile-time", "C++20"]
---

## Topics
- Template instantiation model
- SFINAE
- Concepts & constraints
- Compile-time computation
- Real interview patterns


=== FILE: src/content/tracks/design-pattern-mastery.mdx ===
---
title: "Design Patterns Mastery"
slug: "design-pattern-mastery"
access: "premium"
live: false
price: 499
duration: "30 days"
level: "Advanced"
description: "From template basics to TMP, concepts, and interview-grade mastery. Learn template instantiation, SFINAE, concepts, and compile-time computation patterns."
lessonCount: 80
tags: ["Templates", "Metaprogramming", "Concepts", "SFINAE", "Compile-time", "C++20"]
---

## Topics
- Template instantiation model
- SFINAE
- Concepts & constraints
- Compile-time computation
- Real interview patterns


=== FILE: src/content/tracks/60-day-cpp-interview.mdx ===
---
title: "60-Day C++ Systems Mastery (EDA ‚Ä¢ HFT ‚Ä¢ BigTech)"
slug: "60-day-cpp-interview"
access: "premium"
live: true
price: 4799
duration: "60 days"
level: "Advanced"
description: "A deep, systems-first C++ mastery track for cracking EDA, HFT, and low-latency engineering interviews. Master memory layout, concurrency, lock-free programming, and performance optimization."
lessonCount: 160
tags: ["C++", "Systems", "Concurrency", "Memory", "ABI", "Performance", "EDA", "HFT", "Low Latency"]
---

## Syllabus

### Week 1‚Äì2: C++ Object Model & ABI (Foundation of Systems C++)
- {
  "title": "C++ Object Model & ABI",
  "access": "free",
  "children": [
    { "title": "Object Layout in Memory", "slug": "abi-object-layout", "access": "free" },
    { "title": "Padding & Alignment Rules", "slug": "memory-layout-padding", "access": "free" },
    { "title": "sizeof, alignof & EBO", "slug": "sizeof-alignof-ebo", "access": "free" },
    { "title": "Standard Layout vs Trivial Types", "slug": "standard-layout-trivial", "access": "free" },
    { "title": "POD History & Modern Equivalents", "slug": "pod-history", "access": "free" },

    { "title": "Stack vs Heap vs TLS", "slug": "stack-heap-tls", "access": "free" },
    { "title": "Object Lifetime Storage Duration (static/thread/auto/dynamic)", "slug": "storage-duration", "access": "free" },

    { "title": "References vs Pointers (ABI impact)", "slug": "refs-vs-ptrs-abi", "access": "free" },
    { "title": "Value Categories (lvalue/rvalue/xvalue/prvalue)", "slug": "value-categories", "access": "free" },
    { "title": "RVO/NRVO & Copy Elision (ABI + perf)", "slug": "rvo-nrvo-copy-elision", "access": "free" },

    { "title": "This Pointer, Member Access & Object Model", "slug": "this-pointer-object-model", "access": "premium" },
    { "title": "Name Lookup, Overload Resolution (high-level view)", "slug": "lookup-overload-resolution", "access": "premium" },

    { "title": "Virtual Tables & Dispatch", "slug": "vtables-internals", "access": "premium" },
    { "title": "Virtual Inheritance Internals", "slug": "virtual-inheritance-internals", "access": "premium" },
    { "title": "Multiple Inheritance Layout", "slug": "multiple-inheritance-layout", "access": "premium" },
    { "title": "Diamond & Virtual Bases", "slug": "virtual-base-classes", "access": "premium" },

    { "title": "RTTI internals (typeid/dynamic_cast)", "slug": "rtti-internals", "access": "premium" },
    { "title": "Exception Handling ABI (unwind tables, landing pads)", "slug": "exception-abi-unwinding", "access": "premium" },

    { "title": "Calling Conventions (SysV / MS ABI basics)", "slug": "calling-conventions", "access": "premium" },
    { "title": "Itanium C++ ABI overview (vtable, name mangling)", "slug": "itanium-abi-overview", "access": "premium" },
    { "title": "Name Mangling & Demangling", "slug": "name-mangling-demangling", "access": "premium" },

    { "title": "Object Files & Relocations (ELF basics)", "slug": "elf-object-relocations", "access": "premium" },
    { "title": "ODR (One Definition Rule) + Violations", "slug": "odr-violations", "access": "premium" }
  ]
}

---

### Week 3: Constructors, Lifetimes & RAII (Correctness)
- {
  "title": "Object Lifetime & RAII",
  "access": "free",
  "children": [
    { "title": "Construction & Destruction Order", "slug": "construction-destruction-order", "access": "free" },
    { "title": "Member Initialization Order Pitfalls", "slug": "member-init-order", "access": "free" },
    { "title": "Temporary Materialization & Lifetime Extension", "slug": "temporary-lifetime-extension", "access": "free" },
    { "title": "Dangling References & UB patterns", "slug": "dangling-references-ub", "access": "free" },

    { "title": "Rule of 0/3/5", "slug": "rule-of-5", "access": "free" },
    { "title": "Copy vs Move Semantics", "slug": "copy-vs-move", "access": "free" },
    { "title": "Move-Only Types & API design", "slug": "move-only-types", "access": "premium" },

    { "title": "Exception Safety (basic/strong/nothrow)", "slug": "exception-safety-levels", "access": "premium" },
    { "title": "RAII Patterns (scope_guard, unique_resource)", "slug": "raii-patterns", "access": "premium" },
    { "title": "Resource Ownership Models", "slug": "resource-ownership", "access": "premium" },

    { "title": "Smart Pointers deep dive (unique_ptr/shared_ptr/weak_ptr)", "slug": "smart-pointers-deep-dive", "access": "premium" },
    { "title": "Custom Deleters & Allocators with smart pointers", "slug": "smartptr-deleters-allocators", "access": "premium" },

    { "title": "Perfect Forwarding", "slug": "perfect-forwarding", "access": "premium" },
    { "title": "Universal References & Reference Collapsing", "slug": "ref-collapsing-universal-refs", "access": "premium" },
    { "title": "std::move vs std::forward (gotchas)", "slug": "move-vs-forward", "access": "premium" },

    { "title": "Copy Elision & Return-by-value APIs", "slug": "copy-elision-apis", "access": "premium" },
    { "title": "Explicit, implicit constructors; converting operators", "slug": "explicit-implicit-ctors", "access": "premium" },

    { "title": "Alignment-new & Over-aligned types", "slug": "aligned-new-overaligned", "access": "premium" },
    { "title": "Placement new, launder, strict aliasing", "slug": "placement-new-launder-aliasing", "access": "premium" },

    { "title": "RAII in concurrency (locks, thread joiners)", "slug": "raii-concurrency-guards", "access": "premium" }
  ]
}

---

### Week 4: C++ Memory Model & Concurrency (Hard Interview Core)
- {
  "title": "Concurrency Fundamentals",
  "access": "premium",
  "children": [
    { "title": "C++ Memory Model Explained", "slug": "cpp-memory-model", "access": "premium" },
    { "title": "Data Races vs Race Conditions", "slug": "data-race-vs-race-condition", "access": "premium" },
    { "title": "Happens-Before & Synchronization", "slug": "happens-before", "access": "premium" },

    { "title": "Atomics & Memory Orders (relaxed/acquire/release/seq_cst)", "slug": "atomics-memory-order", "access": "premium" },
    { "title": "Atomic RMW operations (fetch_add/exchange/CAS)", "slug": "atomic-rmw", "access": "premium" },
    { "title": "Atomic fences (atomic_thread_fence)", "slug": "atomic-fences", "access": "premium" },
    { "title": "std::atomic_ref & atomic<T> pitfalls", "slug": "atomic-ref-pitfalls", "access": "premium" },

    { "title": "Cache Coherence & MESI basics", "slug": "cache-coherence-mesi", "access": "premium" },
    { "title": "False Sharing & Cache Lines", "slug": "false-sharing", "access": "premium" },
    { "title": "Memory Reordering (compiler vs CPU)", "slug": "compiler-vs-cpu-reordering", "access": "premium" },

    { "title": "Mutex vs Spinlock vs Futex", "slug": "locks-vs-spinlocks", "access": "premium" },
    { "title": "Condition Variables (lost wakeups, spurious)", "slug": "condition-variables", "access": "premium" },
    { "title": "Reader-Writer Locks & shared_mutex", "slug": "shared-mutex-rwlocks", "access": "premium" },
    { "title": "Deadlocks (avoidance, ordering, try_lock)", "slug": "deadlocks-avoidance", "access": "premium" },
    { "title": "Priority Inversion & real-time considerations", "slug": "priority-inversion", "access": "premium" },

    { "title": "Thread Lifecycle (join/detach), RAII joiners", "slug": "thread-lifecycle", "access": "premium" },
    { "title": "Thread Local Storage (TLS) performance & pitfalls", "slug": "tls-performance", "access": "premium" },

    { "title": "Futures/Promises/packaged_task", "slug": "futures-promises", "access": "premium" },
    { "title": "async launch policies & thread pools", "slug": "async-launch-policies", "access": "premium" },
    { "title": "Latches/Barriers/Semaphores (C++20)", "slug": "latches-barriers-semaphores", "access": "premium" },

    { "title": "Concurrency testing: TSAN, stress tests", "slug": "concurrency-testing-tsan", "access": "premium" }
  ]
}

---

### Week 5: Lock-Free & Wait-Free Design (HFT Level)
- {
  "title": "Lock-Free Programming",
  "access": "premium",
  "children": [
    { "title": "CAS & ABA Problem", "slug": "cas-aba", "access": "premium" },
    { "title": "Tagged Pointers & Version Counters", "slug": "tagged-pointers", "access": "premium" },

    { "title": "Memory Reclamation (Hazard Pointers)", "slug": "hazard-pointers", "access": "premium" },
    { "title": "Epoch-Based Reclamation (EBR/QSBR)", "slug": "epoch-reclamation", "access": "premium" },
    { "title": "RCU basics (read-copy-update)", "slug": "rcu-basics", "access": "premium" },

    { "title": "Lock-Free Stack (Treiber) + pitfalls", "slug": "treiber-stack", "access": "premium" },
    { "title": "Michael-Scott Queue (MSQueue)", "slug": "msqueue", "access": "premium" },

    { "title": "Ring Buffers & SPSC/MPMC", "slug": "ring-buffers", "access": "premium" },
    { "title": "Disruptor Pattern (sequencers, gating sequences)", "slug": "disruptor-pattern", "access": "premium" },

    { "title": "Wait-Free vs Lock-Free vs Obstruction-Free", "slug": "progress-guarantees", "access": "premium" },
    { "title": "Linearizability & correctness proofs (practical)", "slug": "linearizability", "access": "premium" },

    { "title": "Backoff strategies & contention management", "slug": "backoff-contention", "access": "premium" },
    { "title": "NUMA-aware lock-free data structures (overview)", "slug": "numa-lockfree-overview", "access": "premium" }
  ]
}

---

### Week 6: Templates & Compile-Time Mastery
- {
  "title": "Templates & Metaprogramming",
  "access": "premium",
  "children": [
    { "title": "Template Instantiation Model", "slug": "template-instantiation", "access": "premium" },
    { "title": "Two-Phase Name Lookup", "slug": "two-phase-lookup", "access": "premium" },
    { "title": "Dependent Names (typename/template keywords)", "slug": "dependent-names", "access": "premium" },

    { "title": "SFINAE & enable_if", "slug": "sfinae-enable-if", "access": "premium" },
    { "title": "Overload sets with constraints (modern patterns)", "slug": "overload-constraints", "access": "premium" },

    { "title": "Concepts & Constraints", "slug": "concepts-constraints", "access": "premium" },
    { "title": "Requires-expressions & requires-clauses", "slug": "requires-expressions", "access": "premium" },

    { "title": "constexpr & consteval", "slug": "constexpr-consteval", "access": "premium" },
    { "title": "constinit & initialization order issues", "slug": "constinit-init-order", "access": "premium" },
    { "title": "Compile-time computation patterns (CTAD, NTTP)", "slug": "compile-time-patterns", "access": "premium" },

    { "title": "Type Traits & TMP", "slug": "type-traits", "access": "premium" },
    { "title": "std::tuple, std::variant internals (usage + cost model)", "slug": "tuple-variant-cost", "access": "premium" },
    { "title": "Expression Templates (high-level)", "slug": "expression-templates", "access": "premium" },

    { "title": "Modules overview (C++20) + build implications", "slug": "cpp20-modules", "access": "premium" }
  ]
}

---

### Week 7: Performance Engineering & Low Latency
- {
  "title": "Low Latency C++",
  "access": "premium",
  "children": [
    { "title": "Latency vs Throughput", "slug": "latency-vs-throughput", "access": "premium" },
    { "title": "p50/p95/p99 & tail latency control", "slug": "tail-latency", "access": "premium" },

    { "title": "NUMA & Memory Locality", "slug": "numa-locality", "access": "premium" },
    { "title": "CPU Affinity & Pinning (pthread_setaffinity)", "slug": "cpu-affinity-pinning", "access": "premium" },
    { "title": "Thread Scheduling (SCHED_FIFO/RR basics)", "slug": "thread-scheduling", "access": "premium" },

    { "title": "Cache Optimization (AoS vs SoA)", "slug": "cache-optimization", "access": "premium" },
    { "title": "Branch Prediction & Prefetching", "slug": "branch-prediction", "access": "premium" },
    { "title": "SIMD basics (AVX/NEON overview)", "slug": "simd-basics", "access": "premium" },

    { "title": "Avoiding Allocations (arena, monotonic buffer)", "slug": "avoid-allocations", "access": "premium" },
    { "title": "Custom Allocators & PMR (polymorphic allocators)", "slug": "pmr-allocators", "access": "premium" },
    { "title": "Memory Pools, Free-lists, Slab allocators", "slug": "memory-pool-allocators", "access": "premium" },

    { "title": "I/O models: sync vs async, batching, syscall reduction", "slug": "io-models-batching", "access": "premium" },
    { "title": "Lock contention profiling & reduction", "slug": "lock-contention-profiling", "access": "premium" },

    { "title": "Benchmarking Correctly (noise, warmup, pinning)", "slug": "benchmarking", "access": "premium" },
    { "title": "Profiling (perf, VTune basics, flamegraphs)", "slug": "profiling-perf-flamegraphs", "access": "premium" },
    { "title": "Compiler Optimizations (-O2/-O3/LTO/PGO)", "slug": "compiler-opts-lto-pgo", "access": "premium" }
  ]
}

---

### Week 8: Build Systems, ABI & Toolchain (EDA Critical)
- {
  "title": "Build & Toolchain",
  "access": "premium",
  "children": [
    { "title": "CMake Deep Dive (targets, properties, interface libs)", "slug": "cmake-deep-dive", "access": "premium" },
    { "title": "Toolchains, cross-compilation, sysroots", "slug": "cmake-toolchains-cross", "access": "premium" },
    { "title": "Build Types, Sanitizers, Coverage", "slug": "build-sanitizers-coverage", "access": "premium" },

    { "title": "Static vs Dynamic Linking", "slug": "linking-models", "access": "premium" },
    { "title": "Linker Basics (ld, gold, lld) + flags", "slug": "linker-basics", "access": "premium" },
    { "title": "Symbol Visibility", "slug": "symbol-visibility", "access": "premium" },
    { "title": "ELF, PLT/GOT, relocation model", "slug": "elf-plt-got", "access": "premium" },

    { "title": "ABI Stability & Versioning", "slug": "abi-stability", "access": "premium" },
    { "title": "Binary Compatibility", "slug": "binary-compatibility", "access": "premium" },
    { "title": "Symbol Versioning & SONAME", "slug": "soname-symbol-versioning", "access": "premium" },

    { "title": "Debugging toolchain (gdb/lldb) essentials", "slug": "gdb-lldb-essentials", "access": "premium" },
    { "title": "Binary analysis (nm/objdump/readelf/ldd)", "slug": "binary-analysis-tools", "access": "premium" },
    { "title": "Packaging & distribution (rpath, RUNPATH)", "slug": "rpath-runpath", "access": "premium" }
  ]
}

---

### Week 9: Linux Internals for C++ Engineers
- {
  "title": "Linux & OS Internals",
  "access": "premium",
  "children": [
    { "title": "Virtual Memory & Paging", "slug": "virtual-memory", "access": "premium" },
    { "title": "TLB, page faults (minor/major), huge pages", "slug": "tlb-pagefaults-hugepages", "access": "premium" },
    { "title": "mmap/munmap, mprotect, madvise", "slug": "mmap-mprotect-madvise", "access": "premium" },

    { "title": "Syscalls & Context Switch", "slug": "syscalls", "access": "premium" },
    { "title": "Process vs Thread", "slug": "process-vs-thread", "access": "premium" },
    { "title": "Signals, timers, interruption model", "slug": "signals-timers", "access": "premium" },

    { "title": "Schedulers (CFS basics), runqueues, affinity", "slug": "linux-scheduler-cfs", "access": "premium" },
    { "title": "IPC basics (pipes, shared memory, futex)", "slug": "ipc-basics", "access": "premium" },

    { "title": "File Systems Internals (VFS, inode, dentry)", "slug": "filesystem-internals", "access": "premium" },
    { "title": "Disk I/O & page cache", "slug": "disk-io-pagecache", "access": "premium" },

    { "title": "Networking basics (sockets, TCP, Nagle, corking)", "slug": "networking-sockets-tcp", "access": "premium" },
    { "title": "epoll fundamentals (edge vs level)", "slug": "epoll-fundamentals", "access": "premium" },
    { "title": "io_uring model (SQ/CQ, submission batching)", "slug": "io-uring", "access": "premium" },

    { "title": "Time sources (clock_gettime, TSC, rdtsc)", "slug": "time-sources-tsc", "access": "premium" },
    { "title": "Perf counters & observability basics", "slug": "perf-counters-observability", "access": "premium" }
  ]
}

---

### Week 10: Architecture, Interviews & System Design (EDA/HFT Applied)
- {
  "title": "Interview Mastery",
  "access": "premium",
  "children": [
    { "title": "EDA Simulation Kernel Design", "slug": "simulation-kernel", "access": "premium" },
    { "title": "Event-Driven Simulation (timing wheel, delta cycles)", "slug": "event-driven-sim-delta-cycles", "access": "premium" },
    { "title": "Compiled Simulation vs Interpretive (tradeoffs)", "slug": "compiled-vs-interpretive-sim", "access": "premium" },
    { "title": "Parallel/Distributed Simulation Concepts", "slug": "parallel-distributed-simulation", "access": "premium" },
    { "title": "Determinism, Reproducibility & Debugging in Sim", "slug": "sim-determinism-debug", "access": "premium" },

    { "title": "Low Latency Engine Design", "slug": "low-latency-engine", "access": "premium" },
    { "title": "Market Data Pipeline (SPSC rings, batching)", "slug": "market-data-pipeline", "access": "premium" },
    { "title": "Order Router & Risk Checks (latency budget)", "slug": "order-router-risk", "access": "premium" },
    { "title": "Backpressure & overload control", "slug": "backpressure-overload", "access": "premium" },

    { "title": "Memory Pool Design", "slug": "memory-pools", "access": "premium" },
    { "title": "Object Pools, arena allocators, fragmentation control", "slug": "pool-fragmentation-control", "access": "premium" },

    { "title": "Thread Pool & Scheduler Design", "slug": "thread-pools", "access": "premium" },
    { "title": "Work stealing vs work sharing", "slug": "work-stealing", "access": "premium" },
    { "title": "Per-core sharding & actor-like designs", "slug": "per-core-sharding", "access": "premium" },

    { "title": "Debugging Performance Regressions", "slug": "perf-regressions", "access": "premium" },
    { "title": "Interview drills: explain past Cadence/Xcelium porting work architect-style", "slug": "cadence-porting-storytelling", "access": "premium" },

    { "title": "Mock Interviews & Review", "slug": "mock-interviews", "access": "premium" },
    { "title": "C++ Systems Round: 50 rapid-fire questions", "slug": "cpp-systems-rapid-fire", "access": "premium" },
    { "title": "Behavioral: STAR stories for EDA/HFT/BigTech", "slug": "behavioral-star-stories", "access": "premium" }
  ]
}

---

## Bonus Tracks (Optional but High ROI)
- {
  "title": "Bonus: C++ Deep Cuts (for Staff-level confidence)",
  "access": "premium",
  "children": [
    { "title": "Undefined Behavior Catalog (strict aliasing, lifetime, OOB)", "slug": "ub-catalog", "access": "premium" },
    { "title": "C++ Standard Library Performance Model (vector/string/map)", "slug": "stl-performance-model", "access": "premium" },
    { "title": "Allocator-aware containers & PMR end-to-end", "slug": "allocator-aware-pmr", "access": "premium" },
    { "title": "Exception vs error-code tradeoffs in low-latency", "slug": "exceptions-vs-errorcodes", "access": "premium" },
    { "title": "Serialization formats (flatbuffers/capnproto overview)", "slug": "serialization-lowlat", "access": "premium" },
    { "title": "Testing: fuzzing, sanitizers, property-based tests", "slug": "testing-fuzz-sanitizers", "access": "premium" }
  ]
}
```

=== FILE: src/content/blog/what-elite-cpp-interviews-test.mdx ===
---
title: "What Elite C++ Interviews Actually Test"
type: "post"
section: "blog"
access: "free"
tags: ["c++", "systems", "interview"]
description: "A systems-first view of what top companies test beyond DSA."
date: "2026-01-16"
---

## The difference vs normal interviews
Most prep content is DSA. Elite roles test **systems thinking**:
- memory model
- performance intuition
- invariants & correctness


=== FILE: src/content/courses/cpp-object-model.mdx ===
---
title: "C++ Object Model & ABI"
slug: "cpp-object-model"
track: "60-day-cpp-interview"
access: "premium"
description: "Object layout, vtables, padding, and ABI contracts."
---

## This course includes
- Object layout in memory
- ABI stability
- vtables & inheritance
- Padding & alignment


=== FILE: src/content/conferences/2022/cppcon/std-execution.mdx ===
---
title: "Std Execution"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2022"]
description: "Conference summary placeholder."
date: "2022-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2025/cppcon/pattern-matching.mdx ===
---
title: "Pattern Matching"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2025"]
description: "Conference summary placeholder."
date: "2025-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2024/cppcon/contracts-revival.mdx ===
---
title: "Contracts Revival"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2024"]
description: "Conference summary placeholder."
date: "2024-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2023/cppcon/reflection-proposals.mdx ===
---
title: "Reflection Proposals"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2023"]
description: "Conference summary placeholder."
date: "2023-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/cppcon-notes-template.mdx ===
---
title: "C++ Conference Notes Template"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "conferences"]
description: "A reusable template to capture talk notes and takeaways."
date: "2026-01-16"
---

## Talk
**Title:**  
**Speaker:**  
**Core idea:**  

## Takeaways
- ...


=== FILE: src/content/conferences/2017/cppcon/ranges-in-cpp17.mdx ===
---
title: "Ranges In Cpp17"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2017"]
description: "Conference summary placeholder."
date: "2017-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2017/cppcon/lifetime-safety.mdx ===
---
title: "Lifetime Safety"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2017"]
description: "Conference summary placeholder."
date: "2017-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2026/cppcon/future-of-cpp.mdx ===
---
title: "Future Of Cpp"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2026"]
description: "Conference summary placeholder."
date: "2026-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2019/cppcon/modules-overview.mdx ===
---
title: "Modules Overview"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2019"]
description: "Conference summary placeholder."
date: "2019-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2021/cppcon/constexpr-evolution.mdx ===
---
title: "Constexpr Evolution"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2021"]
description: "Conference summary placeholder."
date: "2021-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2020/cppcon/coroutines-deep-dive.mdx ===
---
title: "Coroutines Deep Dive"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2020"]
description: "Conference summary placeholder."
date: "2020-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/conferences/2018/cppcon/value-semantics.mdx ===
---
title: "Value Semantics"
type: "post"
section: "conferences"
access: "free"
tags: ["cppcon", "2018"]
description: "Conference summary placeholder."
date: "2018-09-01"
---

## Summary
TODO

## Key Takeaways
TODO

## Interview Relevance
TODO

=== FILE: src/content/interviews/siemens-eda-questa.mdx ===
---
title: "Siemens EDA (Questa) Interview Notes"
type: "post"
section: "interviews"
access: "free"
tags: ["eda", "interview", "c++"]
description: "What gets asked for simulation/EDA C++ roles and how to prepare."
date: "2026-01-16"
---

## What they care about
- C++ fundamentals (ABI, memory, perf)
- concurrency + correctness
- debugging instincts (repro, isolation, profiling)


=== FILE: src/components/OnThisPage.tsx ===
"use client";

import { useEffect, useMemo, useState } from "react";

type TocItem = { id: string; text: string; level: number };

function slugify(s: string) {
  return s
    .toLowerCase()
    .trim()
    .replace(/[^\w\s-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-");
}

export default function OnThisPage({
  containerId = "mdx-article",
}: {
  containerId?: string;
}) {
  const [items, setItems] = useState<TocItem[]>([]);
  const [activeId, setActiveId] = useState<string>("");

  useEffect(() => {
    const root = document.getElementById(containerId);
    if (!root) return;

    const headings = Array.from(
      root.querySelectorAll<HTMLHeadingElement>("h2, h3")
    );

    const toc: TocItem[] = headings
      .map((h) => {
        const text = (h.textContent || "").trim();
        if (!text) return null;

        // Ensure each heading has an id (works regardless of rehype-slug)
        if (!h.id) h.id = slugify(text);

        return {
          id: h.id,
          text,
          level: h.tagName === "H2" ? 2 : 3,
        } as TocItem;
      })
      .filter(Boolean) as TocItem[];

    setItems(toc);

    if (toc.length === 0) return;

    const obs = new IntersectionObserver(
      (entries) => {
        const visible = entries
          .filter((e) => e.isIntersecting)
          .sort((a, b) => (b.intersectionRatio ?? 0) - (a.intersectionRatio ?? 0));

        if (visible[0]?.target?.id) setActiveId(visible[0].target.id);
      },
      {
        root: null,
        rootMargin: "-20% 0px -70% 0px",
        threshold: [0.1, 0.2, 0.3, 0.4, 0.5],
      }
    );

    headings.forEach((h) => obs.observe(h));
    return () => obs.disconnect();
  }, [containerId]);

  const has = useMemo(() => items.length > 0, [items.length]);
  if (!has) return null;

  return (
    <aside className="hidden lg:block w-64">
      <div className="sticky top-[92px] rounded-2xl border border-gray-200 bg-white/70 backdrop-blur p-4">
        <div className="text-xs font-mono text-gray-500">ON THIS PAGE</div>

        <nav className="mt-3 space-y-1">
          {items.map((it) => (
            <a
              key={it.id}
              href={`#${it.id}`}
              className={[
                "block text-sm transition",
                it.level === 3 ? "pl-3" : "",
                it.id === activeId
                  ? "text-cyan-700 font-semibold"
                  : "text-gray-600 hover:text-gray-900",
              ].join(" ")}
            >
              {it.text}
            </a>
          ))}
        </nav>
      </div>
    </aside>
  );
}

=== FILE: src/components/SiteFooter.tsx ===
import Link from "next/link";

export default function SiteFooter() {
  return (
    <footer className="border-t border-gray-200 bg-white">
      <div className="mx-auto max-w-6xl px-6 py-8 flex flex-col md:flex-row gap-6 md:items-center md:justify-between">
        
        <div className="text-sm text-gray-600">
          <span className="font-mono text-gray-900">
            <span className="text-blue-600">cpp</span>
            valley
            <span className="ml-1 text-blue-600/90">_</span>
          </span>{" "}
          <span className="text-[10px] text-gray-500 border border-gray-200 bg-gray-50 rounded px-2 py-0.5">
            systems-first interview mastery (EDA ‚Ä¢ HFT ‚Ä¢ low latency)
          </span>
        </div>

        <div className="flex flex-wrap gap-4 text-sm text-gray-600">
          <Link className="hover:text-gray-900" href="/learn/tracks">
            Tracks
          </Link>
          <Link className="hover:text-gray-900" href="/interviews">
            Interviews
          </Link>
          <Link className="hover:text-gray-900" href="/conferences">
            Conferences
          </Link>
          <Link className="hover:text-gray-900" href="/pricing">
            Pricing
          </Link>
        </div>
      </div>
    </footer>
  );
}
=== FILE: src/components/TrackProgressPing.tsx ===
"use client";

import { useEffect } from "react";

export default function TrackProgressPing({
  trackSlug,
  lessonSlug,
}: {
  trackSlug: string;
  lessonSlug: string;
}) {
  useEffect(() => {
    fetch("/api/progress/last", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ trackSlug, lessonSlug }),
    }).catch(() => {});
  }, [trackSlug, lessonSlug]);

  return null;
}

=== FILE: src/components/SiteHeader.tsx ===
"use client";

import Link from "next/link";
import { signIn, signOut, useSession } from "next-auth/react";

function NavLink({ href, label }: { href: string; label: string }) {
  return (
    <Link
      href={href}
      className="text-sm text-gray-600 hover:text-gray-900 transition-colors"
    >
      {label}
    </Link>
  );
}

export default function SiteHeader() {
  const { data: session } = useSession();

  return (
    <header className="sticky top-0 z-50 border-b border-gray-200 bg-white/95 backdrop-blur">
      <div className="mx-auto max-w-6xl px-6 py-4 flex items-center justify-between">
        {/* wordmark */}
        <Link
          href="/"
          className="flex items-center gap-2 font-mono tracking-wide text-gray-900 hover:text-gray-700"
        >
          <span>
            <span className="text-blue-600">cpp</span>
            valley
            <span className="ml-1 text-blue-600/90">_</span>
          </span>

          <span className="text-[10px] text-gray-500 border border-gray-200 bg-gray-50 rounded px-2 py-0.5">
            v0.1
          </span>
        </Link>

        {/* nav */}
        <nav className="hidden md:flex items-center gap-6">
          <NavLink href="/learn/tracks" label="Tracks" />
          <NavLink href="/interviews" label="Interviews" />
          <NavLink href="/conferences" label="Conferences" />
          <NavLink href="/pricing" label="Pricing" />
        </nav>

        {/* auth */}
        <div className="flex items-center gap-3">
          {session?.user ? (
            <button
              onClick={() => signOut()}
              className="rounded-lg border border-gray-300 bg-white px-4 py-2 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
            >
              Logout
            </button>
          ) : (
            <button
              onClick={() => signIn("google")}
              className="rounded-lg bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 transition-colors"
            >
              Login with Google
            </button>
          )}
        </div>
      </div>
    </header>
  );
}
=== FILE: src/components/TrackPageLayout.tsx ===
// src/components/TrackPageLayout.tsx - WITH SCROLL CONTROL
"use client";

import { ReactNode, useEffect } from "react";
import TrackHeader from "@/components/TrackHeader";

interface TrackPageLayoutProps {
  children: ReactNode;
  sidebar: ReactNode;
}

export default function TrackPageLayout({ children, sidebar }: TrackPageLayoutProps) {
  useEffect(() => {
    // Disable body scrolling for track pages
    document.documentElement.style.setProperty('--page-scroll', 'hidden');
    
    return () => {
      // Re-enable body scrolling when leaving track page
      document.documentElement.style.setProperty('--page-scroll', 'auto');
    };
  }, []);

  return (
    <div className="h-screen flex flex-col bg-white">
      {/* Fixed Header */}
      <TrackHeader />
      
      {/* Main Content Area - takes remaining space */}
      <div className="flex flex-1 min-h-0">
        {/* Left Sidebar - independent scroll */}
        <div className="hidden lg:block w-64 flex-shrink-0 border-r border-gray-200 bg-white">
          <div className="h-full overflow-y-auto">
            {sidebar}
          </div>
        </div>
        
        {/* Right Content Area - independent scroll */}
        <div className="flex-1 min-w-0 overflow-hidden">
          {children}
        </div>
      </div>
    </div>
  );
}
=== FILE: src/components/RegularPageLayout.tsx ===
// src/components/RegularPageLayout.tsx
import SiteHeader from "./SiteHeader";
import SiteFooter from "./SiteFooter";

export default function RegularPageLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen flex flex-col">
      <SiteHeader />
      <main className="flex-1">
        {children}
      </main>
      <SiteFooter />
    </div>
  );
}
=== FILE: src/components/LessonLayoutWrapper.tsx ===
// src/components/LessonLayoutWrapper.tsx - FIXED INTERNAL SCROLLING
"use client";

import { usePathname } from "next/navigation";
import { useEffect, useState } from "react";
import Link from "next/link";
import { ChevronLeft, ChevronRight } from "lucide-react";

export default function LessonLayoutWrapper({
  children,
  trackSlug,
}: {
  children: React.ReactNode;
  trackSlug: string;
}) {
  const pathname = usePathname();
  const [isLessonPage, setIsLessonPage] = useState(false);
  const [currentLessonSlug, setCurrentLessonSlug] = useState<string | null>(null);
  const [allLessons, setAllLessons] = useState<any[]>([]);
  const [currentIndex, setCurrentIndex] = useState(-1);
  const [currentTitle, setCurrentTitle] = useState("");

  useEffect(() => {
    const match = pathname.match(/\/learn\/tracks\/[^\/]+\/([^\/]+)/);
    const slug = match ? match[1] : null;
    setCurrentLessonSlug(slug);
    setIsLessonPage(!!slug);

    if (slug) {
      fetch(`/api/track/${trackSlug}`)
        .then(res => res.json())
        .then(data => {
          if (data.sections) {
            const flatten = (items: any[], out: any[] = []) => {
              for (const it of items) {
                if (it?.slug) out.push(it);
                if (Array.isArray(it?.children)) flatten(it.children, out);
              }
              return out;
            };
            
            const lessons = flatten(data.sections.flatMap((s: any) => s.items ?? []));
            setAllLessons(lessons);
            const index = lessons.findIndex((x: any) => x.slug === slug);
            setCurrentIndex(index);
            
            if (index >= 0) {
              setCurrentTitle(lessons[index]?.title || "");
            }
          }
        })
        .catch(error => {
          console.error("Failed to load track data:", error);
        });
    }
  }, [pathname, trackSlug]);

  if (!isLessonPage) {
    return (
      <div className="h-full overflow-y-auto">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 py-8">
          {children}
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {/* Fixed Header */}
      <div className="flex-shrink-0 bg-white border-b border-gray-200">
        <div className="max-w-4xl mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <div className="text-lg font-semibold text-gray-900 truncate">
                {currentTitle}
              </div>
              <div className="text-sm text-gray-500 px-2 py-1 bg-gray-100 rounded">
                {currentIndex + 1}/{allLessons.length}
              </div>
            </div>
            <div className="text-sm text-gray-600">
              {trackSlug.replace(/-/g, ' ')}
            </div>
          </div>
        </div>
      </div>

      {/* Scrollable Content Area */}
      <div className="flex-1 overflow-y-auto">
        <div className="max-w-4xl mx-auto px-6 py-6">
          <div className="deepseek-prose">
            {children}
          </div>
          <div className="h-20" />
        </div>
      </div>

      {/* Fixed Navigation Bar */}
      <div className="flex-shrink-0 bg-white border-t border-gray-200">
        <div className="max-w-4xl mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            {/* Previous Lesson */}
            {currentIndex > 0 ? (
              <Link
                href={`/learn/tracks/${trackSlug}/${allLessons[currentIndex - 1].slug}`}
                className="group flex items-center gap-3 px-4 py-3 rounded-xl border border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors"
              >
                <ChevronLeft className="w-5 h-5 text-gray-400 group-hover:text-gray-600" />
                <div className="text-left">
                  <div className="text-xs text-gray-500">Previous</div>
                  <div className="text-sm font-medium text-gray-900 group-hover:text-blue-600 truncate max-w-[200px]">
                    {allLessons[currentIndex - 1]?.title}
                  </div>
                </div>
              </Link>
            ) : (
              <div className="w-48"></div>
            )}

            {/* Lesson Counter */}
            <div className="text-sm text-gray-600 px-4 py-2 bg-gray-100 rounded-lg">
              Lesson {currentIndex + 1} of {allLessons.length}
            </div>

            {/* Next Lesson */}
            {currentIndex < allLessons.length - 1 ? (
              <Link
                href={`/learn/tracks/${trackSlug}/${allLessons[currentIndex + 1].slug}`}
                className="group flex items-center gap-3 px-4 py-3 rounded-xl border border-gray-200 hover:border-gray-300 hover:bg-gray-50 transition-colors"
              >
                <div className="text-right">
                  <div className="text-xs text-gray-500">Next</div>
                  <div className="text-sm font-medium text-gray-900 group-hover:text-blue-600 truncate max-w-[200px]">
                    {allLessons[currentIndex + 1]?.title}
                  </div>
                </div>
                <ChevronRight className="w-5 h-5 text-gray-400 group-hover:text-gray-600" />
              </Link>
            ) : (
              <div className="w-48"></div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
=== FILE: src/components/LessonContentWrapper.tsx ===
// src/components/LessonContentWrapper.tsx
"use client";

import Link from "next/link";
import { useEffect, useMemo, useRef, useState } from "react";
import { usePathname } from "next/navigation";

type AnyItem = { title: string; slug?: string; children?: AnyItem[] };
type Section = { title: string; items: AnyItem[] };
type FlatLesson = { title: string; slug: string };

function flatten(items: AnyItem[], out: FlatLesson[] = []) {
  for (const it of items) {
    if (it.slug) out.push({ title: it.title, slug: it.slug });
    if (Array.isArray(it.children)) flatten(it.children, out);
  }
  return out;
}

function clamp(n: number, min = 0, max = 100) {
  return Math.max(min, Math.min(max, n));
}

/* ---------- Clean circular progress (no text inside) ---------- */
function CircleProgress({ value }: { value: number }) {
  const size = 28;
  const stroke = 3;
  const r = (size - stroke) / 2;
  const c = 2 * Math.PI * r;
  const dash = (clamp(value) / 100) * c;

  return (
    <svg width={size} height={size}>
      <circle
        cx={size / 2}
        cy={size / 2}
        r={r}
        fill="none"
        stroke="rgb(229 231 235)"
        strokeWidth={stroke}
      />
      <circle
        cx={size / 2}
        cy={size / 2}
        r={r}
        fill="none"
        stroke="rgb(8 145 178)"
        strokeWidth={stroke}
        strokeLinecap="round"
        strokeDasharray={`${dash} ${c - dash}`}
        transform={`rotate(-90 ${size / 2} ${size / 2})`}
      />
    </svg>
  );
}

export default function LessonContentWrapper({
  children,
  trackSlug,
  sections,
}: {
  children: React.ReactNode;
  trackSlug: string;
  sections: Section[];
}) {
  const pathname = usePathname();
  const scrollRef = useRef<HTMLDivElement | null>(null);
  const [progress, setProgress] = useState(0);

  const currentLessonSlug = pathname.split("/").pop() || "";

  const lessons = useMemo(() => {
    const safe = Array.isArray(sections) ? sections : [];
    return flatten(safe.flatMap((s) => s.items || []));
  }, [sections]);

  const currentIndex = lessons.findIndex((l) => l.slug === currentLessonSlug);
  const currentTitle =
    currentIndex >= 0 ? lessons[currentIndex].title : currentLessonSlug;

  const prev = currentIndex > 0 ? lessons[currentIndex - 1] : null;
  const next =
    currentIndex >= 0 && currentIndex < lessons.length - 1
      ? lessons[currentIndex + 1]
      : null;

  /* ---------- PURE SCROLL LOGIC ---------- */
  useEffect(() => {
    const el = scrollRef.current;
    if (!el) return;

    const onScroll = () => {
      const max = el.scrollHeight - el.clientHeight;
      if (max <= 0) {
        setProgress(100);
        return;
      }
      const pct = (el.scrollTop / max) * 100;
      setProgress(clamp(pct));
    };

    onScroll();
    el.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", onScroll);

    return () => {
      el.removeEventListener("scroll", onScroll);
      window.removeEventListener("resize", onScroll);
    };
  }, [currentLessonSlug]);

  return (
    <div className="h-full min-h-0 flex flex-col bg-white">
      {/* TOP BAR */}
      <div className="h-[64px] border-b border-gray-200 flex-shrink-0 bg-white">
        <div className="h-full max-w-[760px] mx-auto px-6 flex items-center justify-between">
          <div className="min-w-0">
            <div className="text-[15px] font-semibold text-gray-900 truncate">
              {currentTitle}
            </div>
            <div className="text-[11px] text-gray-500">
              {currentIndex + 1} / {lessons.length}
            </div>
          </div>

          <CircleProgress value={progress} />
        </div>
      </div>

      {/* SCROLLABLE CONTENT */}
      <div
        ref={scrollRef}
        className="flex-1 min-h-0 overflow-y-auto bg-white"
      >
        <div className="max-w-[760px] mx-auto px-6 py-8 pb-24">
          <div className="deepseek-prose">{children}</div>
        </div>
      </div>

      {/* BOTTOM BAR */}
      <div className="h-[56px] border-t border-gray-200 flex-shrink-0 bg-white">
        <div className="h-full max-w-[760px] mx-auto px-6 flex items-center justify-between">
          <div>
            {prev && (
              <Link
                href={`/learn/tracks/${trackSlug}/${prev.slug}`}
                className="text-sm text-gray-700 hover:text-gray-900"
              >
                ‚Üê Previous
              </Link>
            )}
          </div>

          <div>
            {next && (
              <Link
                href={`/learn/tracks/${trackSlug}/${next.slug}`}
                className="text-sm font-medium text-cyan-700 hover:text-cyan-900"
              >
                Next ‚Üí
              </Link>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

=== FILE: src/components/TrackLayout.tsx ===
// src/components/TrackLayout.tsx
"use client";

import { ReactNode, useEffect } from "react";

export default function TrackLayout({
  children,
  sidebar,
}: {
  children: ReactNode;
  sidebar: ReactNode;
}) {
  useEffect(() => {
    // lock window scroll (ChatGPT-like app shell)
    const prev = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = prev || "auto";
    };
  }, []);

  return (
    <div className="h-screen overflow-hidden bg-white">
      <div className="flex h-full min-h-0">
        {/* LEFT: independent scroll handled inside TrackSidebar */}
        <aside className="hidden lg:block w-72 flex-shrink-0 border-r border-gray-200 bg-white">
          {sidebar}
        </aside>

        {/* RIGHT: fixed header + scrollable middle + fixed footer (inside LessonContentWrapper) */}
        <main className="flex-1 min-w-0 min-h-0 bg-white">
          {children}
        </main>
      </div>
    </div>
  );
}

=== FILE: src/components/ContentCard.tsx ===
import Link from "next/link";
import { ContentMeta } from "@/lib/content";

const badgeColor = {
  free: "bg-green-100 text-green-800",
  premium: "bg-purple-100 text-purple-800",
  paid: "bg-orange-100 text-orange-800",
};

export default function ContentCard({ item }: { item: ContentMeta }) {
  return (
    <div className="rounded-xl border p-5 hover:shadow-sm transition">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-semibold">
          <Link href={`/${item.section}/${item.slug}`}>{item.title}</Link>
        </h3>

        <span
          className={`text-xs px-2 py-1 rounded ${
            badgeColor[item.access] ?? badgeColor.free
          }`}
        >
          {item.access.toUpperCase()}
        </span>
      </div>

      {item.description && (
        <p className="mt-2 text-sm text-gray-600">{item.description}</p>
      )}

      {item.tags && item.tags.length > 0 && (
        <div className="mt-3 flex flex-wrap gap-2">
          {item.tags.map((tag) => (
            <span
              key={tag}
              className="
                text-xs
                bg-gray-200 text-gray-900
                dark:bg-gray-800 dark:text-gray-100
                px-2 py-1 rounded
              "
            >
              {tag}
            </span>
          ))}
        </div>
      )}
    </div>
  );
}


=== FILE: src/components/TrackHeader.tsx ===
// src/components/TrackHeader.tsx - MAKE SURE THIS EXISTS
"use client";

import Link from "next/link";
import { signIn, signOut, useSession } from "next-auth/react";

export default function TrackHeader() {
  const { data: session } = useSession();

  return (
    <div className="h-16 border-b border-gray-200 bg-white flex items-center px-6">
      {/* Left: cppvalley logo */}
      <Link
        href="/"
        className="flex items-center gap-2 font-mono tracking-wide text-gray-900 hover:text-gray-700"
      >
        <span>
          <span className="text-blue-600">cpp</span>
          valley
          <span className="ml-1 text-blue-600/90">_</span>
        </span>
        <span className="text-[10px] text-gray-500 border border-gray-200 bg-gray-50 rounded px-2 py-0.5">
          v0.1
        </span>
      </Link>

      {/* Spacer */}
      <div className="flex-1"></div>

      {/* Right: Auth */}
      <div className="flex items-center gap-3">
        {session?.user ? (
          <button
            onClick={() => signOut()}
            className="text-sm text-gray-600 hover:text-gray-900 px-3 py-1.5 rounded-lg hover:bg-gray-50 transition-colors"
          >
            Logout
          </button>
        ) : (
          <button
            onClick={() => signIn("google")}
            className="text-sm text-blue-600 hover:text-blue-700 px-3 py-1.5 rounded-lg hover:bg-blue-50 transition-colors"
          >
            Login
          </button>
        )}
      </div>
    </div>
  );
}
=== FILE: src/components/TrackSidebar.tsx ===
// src/components/TrackSidebar.tsx
"use client";

import Link from "next/link";
import { useMemo, useState, useEffect } from "react";
import { usePathname } from "next/navigation";
import { ChevronRight, Lock, Check } from "lucide-react";
import { signIn, signOut, useSession } from "next-auth/react";

type AnyItem = {
  title: string;
  slug?: string;
  access?: "free" | "premium" | "paid";
  children?: AnyItem[];
};

type Section = { title: string; items: AnyItem[] };

function findContainsSlug(items: AnyItem[], slug: string): boolean {
  for (const it of items) {
    if (it.slug === slug) return true;
    if (it.children && findContainsSlug(it.children, slug)) return true;
  }
  return false;
}

const STORAGE_KEY = "cppvalley.completedLessons";

export default function TrackSidebar({
  trackSlug,
  sections,
}: {
  trackSlug: string;
  sections: Section[];
}) {
  const { data: session } = useSession();
  const pathname = usePathname();
  const currentLessonSlug = pathname.split("/").pop() || "";
  const safeSections = Array.isArray(sections) ? sections : [];

  /* ---------------- completed (localStorage) ---------------- */
  const [completed, setCompleted] = useState<Record<string, boolean>>({});

  useEffect(() => {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) setCompleted(JSON.parse(raw));
    } catch {}
  }, []);

  useEffect(() => {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(completed));
    } catch {}
  }, [completed]);

  const toggleCompleted = (slug: string) =>
    setCompleted((prev) => ({ ...prev, [slug]: !prev[slug] }));

  /* ---------------- open sections ---------------- */
  const initialOpen = useMemo(() => {
    const m: Record<number, boolean> = {};
    for (let i = 0; i < safeSections.length; i++) {
      const sec = safeSections[i];
      m[i] = currentLessonSlug
        ? findContainsSlug(sec.items || [], currentLessonSlug)
        : i === 0;
    }
    return m;
  }, [safeSections, currentLessonSlug]);

  const [openSections, setOpenSections] =
    useState<Record<number, boolean>>(initialOpen);

  const toggleSection = (i: number) =>
    setOpenSections((prev) => ({ ...prev, [i]: !prev[i] }));

  const isLocked = (item: AnyItem) =>
    item.access === "premium" || item.access === "paid";

  const renderItem = (item: AnyItem, depth = 0) => {
    const locked = isLocked(item);
    const isActive = item.slug === currentLessonSlug;
    const href = item.slug ? `/learn/tracks/${trackSlug}/${item.slug}` : "#";
    const isDone = !!(item.slug && completed[item.slug]);

    return (
      <div key={`${item.title}-${item.slug ?? "no-slug"}-${depth}`}>
        {item.slug ? (
          <div
            className={[
              "group relative flex items-center gap-2 rounded-lg px-2 py-2 text-sm transition-colors",
              depth > 0 ? "ml-3" : "",
              isActive
                ? "bg-cyan-50 ring-1 ring-cyan-200"
                : "hover:bg-gray-50",
            ].join(" ")}
          >
            {/* completion checkbox */}
            <button
              onClick={(e) => {
                e.preventDefault();
                e.stopPropagation();
                toggleCompleted(item.slug!);
              }}
              className={[
                "flex-shrink-0 h-4 w-4 rounded border flex items-center justify-center transition",
                isDone
                  ? "bg-cyan-600 border-cyan-600"
                  : "border-gray-300 hover:border-gray-400",
              ].join(" ")}
              aria-label="Mark as completed"
              title="Mark as completed"
            >
              {isDone ? <Check className="h-3 w-3 text-white" /> : null}
            </button>

            {/* title link (NO strike-through) */}
            <Link
              href={href}
              aria-current={isActive ? "page" : undefined}
              className="flex items-center min-w-0 flex-1"
            >
              <span
                className={[
                  "truncate",
                  isActive ? "font-semibold text-gray-900" : "text-gray-800",
                  isDone ? "text-gray-700" : "",
                ].join(" ")}
              >
                {item.title}
              </span>
            </Link>

            {/* üîí Lock icon only, subtle color */}
            {locked ? (
              <Lock
                className={[
                  "h-4 w-4 flex-shrink-0",
                  isActive ? "text-cyan-600" : "text-gray-400",
                ].join(" ")}
                strokeWidth={1.5}
              />
            ) : null}

            {/* active rail */}
            {isActive ? (
              <span className="pointer-events-none absolute left-0 top-1/2 -translate-y-1/2 h-6 w-1 rounded-r bg-cyan-600" />
            ) : null}
          </div>
        ) : (
          <div
            className={[
              "px-2 py-1 text-xs text-gray-600",
              depth > 0 ? "ml-3" : "",
            ].join(" ")}
          >
            {item.title}
          </div>
        )}

        {/* children */}
        {Array.isArray(item.children) && item.children.length > 0 ? (
          <div className="mt-1 space-y-1">
            {item.children.map((ch) => renderItem(ch, depth + 1))}
          </div>
        ) : null}
      </div>
    );
  };

  return (
    <div className="h-full min-h-0 flex flex-col bg-white">
      {/* TOP */}
      <div className="flex-shrink-0 h-[64px] border-b border-gray-200 bg-white">
        <div className="h-full px-4 flex items-center">
          <Link
            href="/"
            className="flex items-center gap-2 font-mono tracking-wide text-gray-900"
          >
            <span>
              <span className="text-cyan-600">cpp</span>valley
              <span className="ml-1 text-cyan-600/90">_</span>
            </span>
            <span className="text-[10px] text-gray-500 border border-gray-200 bg-gray-50 rounded px-2 py-0.5">
              v0.1
            </span>
          </Link>
        </div>
      </div>

      {/* MIDDLE */}
      <div className="flex-1 min-h-0 overflow-y-auto px-3 py-4">
        <div className="space-y-4">
          {safeSections.map((section, i) => (
            <div key={`${section.title}-${i}`} className="space-y-2">
              <button
                onClick={() => toggleSection(i)}
                className="w-full flex items-center justify-between rounded-lg px-2 py-2 hover:bg-gray-50 transition-colors"
              >
                <div className="flex items-center gap-2 min-w-0">
                  <ChevronRight
                    className={[
                      "h-4 w-4 text-gray-400 transition-transform",
                      openSections[i] ? "rotate-90" : "",
                    ].join(" ")}
                  />
                  <span className="text-sm font-semibold text-gray-900 truncate text-left">
                    {section.title}
                  </span>
                </div>
              </button>

              {openSections[i] ? (
                <div className="space-y-1">
                  {(section.items || []).map((it) => renderItem(it))}
                </div>
              ) : null}
            </div>
          ))}
        </div>
      </div>

      {/* BOTTOM */}
      <div className="flex-shrink-0 h-[56px] border-t border-gray-200 bg-white">
        <div className="h-full px-4 flex items-center justify-between">
          <div className="text-xs text-gray-500 truncate">tracks ‚Ä¢ {trackSlug}</div>

          {session?.user ? (
            <button
              onClick={() => signOut()}
              className="rounded-lg border border-gray-300 bg-white px-3 py-1.5 text-xs text-gray-700 hover:bg-gray-50"
            >
              Logout
            </button>
          ) : (
            <button
              onClick={() => signIn("google")}
              className="rounded-lg bg-cyan-600 px-3 py-1.5 text-xs font-semibold text-white hover:bg-cyan-700"
            >
              Login
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

=== FILE: src/components/MdxRenderer.tsx ===
// src/components/MdxRenderer.tsx - SIMPLIFIED
import { MDXRemote } from "next-mdx-remote/rsc";
import CodeBlock from "@/components/CodeBlock";

const components = { 
  pre: CodeBlock,
};

export default function MdxRenderer({ source }: { source: string }) {
  return (
    <article className="text-gray-800">
      <MDXRemote source={source} components={components} />
    </article>
  );
}
=== FILE: src/components/TrackReaderShell.tsx ===
"use client";

import Link from "next/link";
import { useEffect, useMemo, useRef, useState } from "react";
import { useSession } from "next-auth/react";
import {
  Lock,
  Search,
  ChevronLeft,
  ChevronRight,
  CheckCircle2,
} from "lucide-react";

type Access = "free" | "premium" | "paid";

type TrackSyllabusItem =
  | { title: string; slug: string; access: Access }
  | {
      title: string;
      access: Access;
      children: { title: string; slug: string; access: Access }[];
    };

type TrackSection = {
  title: string;
  items: TrackSyllabusItem[];
};

function clamp(n: number, a: number, b: number) {
  return Math.max(a, Math.min(b, n));
}

function calcScrollPercent(el: HTMLElement | null) {
  if (!el) return 0;
  const max = el.scrollHeight - el.clientHeight;
  if (max <= 0) return 0;
  return clamp(el.scrollTop / max, 0, 1);
}

function ProgressRing({ value }: { value: number }) {
  // 0..1
  const pct = clamp(value, 0, 1);
  const size = 26;
  const r = 11;
  const c = 2 * Math.PI * r;
  const dash = c * pct;

  return (
    <svg width={size} height={size} viewBox="0 0 26 26" className="shrink-0">
      <circle
        cx="13"
        cy="13"
        r={r}
        fill="none"
        stroke="rgba(15, 23, 42, 0.12)"
        strokeWidth="2.5"
      />
      <circle
        cx="13"
        cy="13"
        r={r}
        fill="none"
        stroke="rgba(6, 182, 212, 0.95)"
        strokeWidth="2.5"
        strokeLinecap="round"
        strokeDasharray={`${dash} ${c - dash}`}
        transform="rotate(-90 13 13)"
      />
    </svg>
  );
}

function flattenLessonSlugs(sections: TrackSection[]) {
  const out: string[] = [];
  for (const sec of sections) {
    for (const it of sec.items as any[]) {
      if (it?.children && Array.isArray(it.children)) {
        for (const c of it.children) if (c?.slug) out.push(c.slug);
      } else if (it?.slug) out.push(it.slug);
    }
  }
  // preserve order; remove duplicates
  return Array.from(new Set(out));
}

export default function TrackReaderShell({
  trackSlug,
  trackTitle,
  lessonSlug,
  lessonTitle,
  sections,
  canAccessPremium,
  children,
}: {
  trackSlug: string;
  trackTitle: string;
  lessonSlug: string;
  lessonTitle: string;
  sections: TrackSection[];
  canAccessPremium: boolean;
  children: React.ReactNode;
}) {
  const { data: session } = useSession();
  const userKey = session?.user?.email || "anon";

  const ordered = useMemo(() => flattenLessonSlugs(sections), [sections]);
  const idx = Math.max(0, ordered.indexOf(lessonSlug));
  const prevSlug = idx > 0 ? ordered[idx - 1] : null;
  const nextSlug = idx >= 0 && idx < ordered.length - 1 ? ordered[idx + 1] : null;

  const [query, setQuery] = useState("");
  const rightRef = useRef<HTMLDivElement | null>(null);

  // scroll progress (0..1)
  const storageKey = `cppvalley:scroll:${userKey}:${trackSlug}:${lessonSlug}`;
  const [progress, setProgress] = useState(0);

  // restore scroll + progress on mount
  useEffect(() => {
    try {
      const raw = localStorage.getItem(storageKey);
      if (raw) {
        const v = Number(raw);
        if (!Number.isNaN(v)) setProgress(clamp(v, 0, 1));
      }
    } catch {}
    // restore scrollTop too (nice UX)
    try {
      const rawTop = localStorage.getItem(`${storageKey}:top`);
      const top = rawTop ? Number(rawTop) : 0;
      if (rightRef.current && !Number.isNaN(top)) {
        rightRef.current.scrollTop = clamp(top, 0, rightRef.current.scrollHeight);
      }
    } catch {}
  }, [storageKey]);

  // track scroll continuously
  useEffect(() => {
    const el = rightRef.current;
    if (!el) return;

    let raf = 0;
    const onScroll = () => {
      cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        const p = calcScrollPercent(el);
        setProgress(p);
        try {
          localStorage.setItem(storageKey, String(p));
          localStorage.setItem(`${storageKey}:top`, String(el.scrollTop));
        } catch {}
      });
    };

    el.addEventListener("scroll", onScroll, { passive: true });
    // init
    onScroll();

    return () => {
      cancelAnimationFrame(raf);
      el.removeEventListener("scroll", onScroll);
    };
  }, [storageKey]);

  // update "last lesson" server-side (your existing endpoint) ‚Äì best effort
  useEffect(() => {
    // only if logged-in
    if (!session?.user?.email) return;
    fetch("/api/progress/last", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ trackSlug, lessonSlug }),
    }).catch(() => {});
  }, [session?.user?.email, trackSlug, lessonSlug]);

  const filteredSections = useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return sections;

    const match = (s: string) => s.toLowerCase().includes(q);

    return sections
      .map((sec) => {
        const items: TrackSyllabusItem[] = [];

        for (const it of sec.items) {
          // module
          if ((it as any).children) {
            const mod = it as any;
            const childHits = (mod.children as any[]).filter(
              (c) => match(c.title) || match(c.slug)
            );
            if (match(mod.title) || childHits.length > 0) {
              items.push({
                title: mod.title,
                access: mod.access,
                children: childHits.length ? childHits : mod.children,
              } as any);
            }
          } else {
            const leaf = it as any;
            if (match(leaf.title) || match(leaf.slug)) items.push(it);
          }
        }

        return { ...sec, items };
      })
      .filter((s) => s.items.length > 0);
  }, [sections, query]);

  return (
    <div className="h-[100dvh] bg-white text-gray-900">
      <div className="grid h-full grid-cols-[320px_1fr]">
        {/* LEFT SIDEBAR */}
        <aside className="border-r border-gray-200 bg-white">
          <div className="flex h-full flex-col">
            {/* left top - brand (height aligned with top bar) */}
            <div className="h-12 border-b border-gray-200 px-4 flex items-center">
              <Link
                href="/"
                className="font-mono tracking-wide text-gray-900 hover:text-cyan-700 transition"
              >
                <span className="text-cyan-600">cpp</span>valley
                <span className="text-cyan-600">_</span>
              </Link>
            </div>

            {/* search */}
            <div className="px-4 py-3 border-b border-gray-200">
              <div className="relative">
                <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
                <input
                  value={query}
                  onChange={(e) => setQuery(e.target.value)}
                  placeholder="Search in this track‚Ä¶"
                  className="w-full rounded-lg border border-gray-200 bg-white pl-9 pr-3 py-2 text-sm outline-none focus:ring-2 focus:ring-cyan-200"
                />
              </div>
            </div>

            {/* scrollable syllabus */}
            <div className="min-h-0 flex-1 overflow-y-auto px-3 py-4">
              <div className="space-y-4">
                {filteredSections.map((sec) => (
                  <div key={sec.title}>
                    <div className="px-2 text-xs font-mono uppercase tracking-wide text-gray-500">
                      {sec.title}
                    </div>

                    <div className="mt-2 space-y-1">
                      {sec.items.map((it: any, i: number) => {
                        // module
                        if (it.children) {
                          return (
                            <div key={`${sec.title}-${i}`} className="mt-3">
                              <div className="px-2 text-[12px] font-semibold text-gray-800 flex items-center gap-2">
                                <span>{it.title}</span>
                                {it.access !== "free" && !canAccessPremium && (
                                  <Lock className="h-3.5 w-3.5 text-cyan-600" />
                                )}
                              </div>

                              <div className="mt-1 space-y-1">
                                {it.children.map((c: any) => {
                                  const isCurrent = c.slug === lessonSlug;
                                  const locked = c.access !== "free" && !canAccessPremium;

                                  return (
                                    <Link
                                      key={c.slug}
                                      href={
                                        locked
                                          ? `/pricing?track=${trackSlug}`
                                          : `/learn/tracks/${trackSlug}/${c.slug}`
                                      }
                                      className={`flex items-center gap-2 rounded-lg px-2 py-1.5 text-sm transition ${
                                        isCurrent
                                          ? "bg-cyan-50 text-cyan-800 font-medium"
                                          : "text-gray-700 hover:bg-gray-50"
                                      }`}
                                    >
                                      <div
                                        className={`h-1.5 w-1.5 rounded-full ${
                                          isCurrent ? "bg-cyan-600" : "bg-gray-300"
                                        }`}
                                      />
                                      <span className="truncate">{c.title}</span>
                                      {locked && (
                                        <Lock className="ml-auto h-4 w-4 text-cyan-600" />
                                      )}
                                    </Link>
                                  );
                                })}
                              </div>
                            </div>
                          );
                        }

                        // leaf
                        const isCurrent = it.slug === lessonSlug;
                        const locked = it.access !== "free" && !canAccessPremium;

                        return (
                          <Link
                            key={it.slug}
                            href={
                              locked
                                ? `/pricing?track=${trackSlug}`
                                : `/learn/tracks/${trackSlug}/${it.slug}`
                            }
                            className={`flex items-center gap-2 rounded-lg px-2 py-1.5 text-sm transition ${
                              isCurrent
                                ? "bg-cyan-50 text-cyan-800 font-medium"
                                : "text-gray-700 hover:bg-gray-50"
                            }`}
                          >
                            <div
                              className={`h-1.5 w-1.5 rounded-full ${
                                isCurrent ? "bg-cyan-600" : "bg-gray-300"
                              }`}
                            />
                            <span className="truncate">{it.title}</span>
                            {locked && (
                              <Lock className="ml-auto h-4 w-4 text-cyan-600" />
                            )}
                          </Link>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* left bottom - auth/status (height aligned with bottom bar) */}
            <div className="h-12 border-t border-gray-200 px-4 flex items-center justify-between">
              <span className="text-xs font-mono text-gray-500 truncate">
                {session?.user?.email ? `signed in` : `guest`}
              </span>
              <Link
                href="/pricing"
                className="text-xs font-mono text-cyan-700 hover:text-cyan-800"
              >
                upgrade ‚Üí
              </Link>
            </div>
          </div>
        </aside>

        {/* RIGHT CONTENT */}
        <section className="min-w-0 bg-white">
          <div className="flex h-full flex-col">
            {/* top bar (aligned height with left brand bar) */}
            <div className="h-12 border-b border-gray-200 bg-white/80 backdrop-blur">
              <div className="h-full px-5 flex items-center justify-between gap-4">
                <div className="min-w-0">
                  <div className="text-[12px] font-mono text-gray-500 truncate">
                    {trackTitle}
                  </div>
                  <div className="text-sm font-semibold text-gray-900 truncate">
                    {lessonTitle}
                  </div>
                </div>

                <div className="flex items-center gap-3">
                  <ProgressRing value={progress} />
                </div>
              </div>
            </div>

            {/* scrollable lesson body */}
            <div
              ref={rightRef}
              className="min-h-0 flex-1 overflow-y-auto px-5 py-6"
            >
              <div className="mx-auto w-full max-w-3xl">
                {/* subtle top abstract glow (same feel as conference/interview) */}
                <div className="pointer-events-none absolute inset-0 -z-10">
                  <div className="absolute -top-32 right-0 h-72 w-72 rounded-full bg-cyan-400/10 blur-3xl" />
                  <div className="absolute top-24 left-10 h-72 w-72 rounded-full bg-emerald-400/10 blur-3xl" />
                </div>

                <article className="prose prose-gray max-w-none">
                  {children}
                </article>
              </div>
            </div>

            {/* bottom nav (aligned height with left bottom bar) */}
            <div className="h-12 border-t border-gray-200 bg-white/80 backdrop-blur">
              <div className="h-full px-5 flex items-center justify-between">
                <div className="flex items-center gap-2">
                  {prevSlug ? (
                    <Link
                      href={`/learn/tracks/${trackSlug}/${prevSlug}`}
                      className="inline-flex items-center gap-2 rounded-lg border border-gray-200 bg-white px-3 py-2 text-sm hover:bg-gray-50 transition"
                    >
                      <ChevronLeft className="h-4 w-4" />
                      Previous
                    </Link>
                  ) : (
                    <span className="inline-flex items-center gap-2 rounded-lg border border-gray-100 bg-gray-50 px-3 py-2 text-sm text-gray-400">
                      <ChevronLeft className="h-4 w-4" />
                      Previous
                    </span>
                  )}
                </div>

                {/* keep the old important "1/160" style info (but clean) */}
                <div className="text-xs font-mono text-gray-500">
                  {idx + 1}/{Math.max(1, ordered.length)}
                </div>

                <div className="flex items-center gap-2">
                  {nextSlug ? (
                    <Link
                      href={`/learn/tracks/${trackSlug}/${nextSlug}`}
                      className="inline-flex items-center gap-2 rounded-lg bg-cyan-600 px-3 py-2 text-sm font-semibold text-white hover:bg-cyan-700 transition"
                    >
                      Next
                      <ChevronRight className="h-4 w-4" />
                    </Link>
                  ) : (
                    <span className="inline-flex items-center gap-2 rounded-lg border border-gray-100 bg-gray-50 px-3 py-2 text-sm text-gray-400">
                      Next
                      <ChevronRight className="h-4 w-4" />
                    </span>
                  )}

                  {/* optional ‚Äúdone‚Äù indicator (not redundant; uses the same ring) */}
                  {progress > 0.98 && (
                    <span className="ml-2 inline-flex items-center gap-1 text-xs font-mono text-emerald-700">
                      <CheckCircle2 className="h-4 w-4" />
                      done
                    </span>
                  )}
                </div>
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>
  );
}

=== FILE: src/components/CodeBlock.tsx ===
"use client";

import { useState } from "react";

export default function CodeBlock({ children }: { children: any }) {
  const [copied, setCopied] = useState(false);

  const code =
    typeof children === "string"
      ? children
      : children?.props?.children ?? "";

  async function copy() {
    await navigator.clipboard.writeText(code);
    setCopied(true);
    setTimeout(() => setCopied(false), 1200);
  }

  return (
    <div className="relative my-6">
      {/* Copy button */}
      <button
        onClick={copy}
        className="
          absolute right-3 top-3 z-10
          rounded-md border border-slate-300
          bg-white px-2 py-1 text-xs font-medium text-slate-600
          hover:bg-slate-100
        "
      >
        {copied ? "Copied" : "Copy"}
      </button>

      <pre
        className="
          overflow-x-auto rounded-xl
          border border-slate-300
          bg-slate-100
          px-4 py-4
          text-sm leading-6
          text-slate-900
        "
      >
        <code className="font-mono">{code}</code>
      </pre>
    </div>
  );
}

=== FILE: src/components/TableOfContents.tsx ===
// src/components/TableOfContents.tsx - Clean version
"use client";

import Link from "next/link";
import { useState } from "react";
import { ChevronRight } from "lucide-react";

export default function TableOfContents({ 
  sections, 
  trackSlug,
  currentLessonSlug 
}: { 
  sections: any[];
  trackSlug: string;
  currentLessonSlug: string;
}) {
  const [openSections, setOpenSections] = useState<Record<number, boolean>>(
    Object.fromEntries(sections.map((_, i) => [i, true]))
  );

  const toggleSection = (i: number) => {
    setOpenSections(prev => ({ ...prev, [i]: !prev[i] }));
  };

  return (
    <div className="space-y-6">
      <div>
        <h3 className="text-sm font-semibold text-gray-900 mb-4">Contents</h3>
        
        <div className="space-y-1">
          {sections.map((section, i) => (
            <div key={i} className="space-y-1">
              <button
                onClick={() => toggleSection(i)}
                className="w-full flex items-center justify-between px-2 py-2 rounded text-sm text-gray-700 hover:text-gray-900 hover:bg-gray-50 transition-colors"
              >
                <span className="font-medium text-left">{section.title}</span>
                <ChevronRight 
                  className={`w-3 h-3 transition-transform duration-200 ${
                    openSections[i] ? 'rotate-90' : ''
                  }`}
                />
              </button>

              {openSections[i] && (
                <div className="ml-2 space-y-1 border-l border-gray-200 pl-3">
                  {section.items?.map((item: any, idx: number) => (
                    <LessonItem
                      key={idx}
                      item={item}
                      trackSlug={trackSlug}
                      currentLessonSlug={currentLessonSlug}
                      depth={0}
                    />
                  ))}
                </div>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

function LessonItem({ item, trackSlug, currentLessonSlug, depth }: any) {
  const [open, setOpen] = useState(depth === 0);
  const hasChildren = item.children?.length > 0;
  const isCurrent = item.slug === currentLessonSlug;

  if (!item.slug) {
    return (
      <div className="space-y-1">
        <button
          onClick={() => setOpen(!open)}
          className="w-full flex items-center justify-between px-2 py-2 rounded text-sm text-gray-600 hover:text-gray-900 hover:bg-gray-50 transition-colors"
        >
          <span className="text-left">{item.title}</span>
          {hasChildren && (
            <ChevronRight 
              className={`w-3 h-3 transition-transform duration-200 ${
                open ? 'rotate-90' : ''
              }`}
            />
          )}
        </button>

        {open && hasChildren && (
          <div className="ml-2 space-y-1 border-l border-gray-200 pl-3">
            {item.children.map((child: any, idx: number) => (
              <LessonItem
                key={idx}
                item={child}
                trackSlug={trackSlug}
                currentLessonSlug={currentLessonSlug}
                depth={depth + 1}
              />
            ))}
          </div>
        )}
      </div>
    );
  }

  return (
    <Link
      href={`/learn/tracks/${trackSlug}/${item.slug}`}
      className={`flex items-center gap-2 px-2 py-2 rounded text-sm transition-colors ${
        isCurrent
          ? 'text-blue-600 bg-blue-50 font-medium'
          : 'text-gray-600 hover:text-gray-900 hover:bg-gray-50'
      }`}
    >
      <div className={`w-1.5 h-1.5 rounded-full ${
        isCurrent ? 'bg-blue-500' : 'bg-gray-300'
      }`} />
      <span className="truncate">{item.title}</span>
    </Link>
  );
}
=== FILE: src/components/Providers.tsx ===
"use client";
import { SessionProvider } from "next-auth/react";

export default function Providers({ children }: { children: React.ReactNode }) {
  return <SessionProvider>{children}</SessionProvider>;
}

=== FILE: src/lib/prisma.ts ===
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as { prisma?: PrismaClient };

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ["error"],
  });

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

=== FILE: src/lib/progress.ts ===
import { prisma } from "@/lib/prisma";
import { authOptions } from "@/auth";
import { getServerSession } from "next-auth";

export async function getUserIdOrNull() {
  const session = await getServerSession(authOptions);
  const email = session?.user?.email;
  if (!email) return null;

  const user = await prisma.user.findUnique({ where: { email } });
  return user?.id ?? null;
}

export async function getProgress(trackSlug: string) {
  const userId = await getUserIdOrNull();
  if (!userId) return null;

  return prisma.progress.findUnique({
    where: { userId_trackSlug: { userId, trackSlug } },
  });
}

=== FILE: src/lib/content.ts ===
import fs from "fs";
import path from "path";
import matter from "gray-matter";
import { notFound } from "next/navigation";

export type Access = "free" | "premium" | "paid";
export type ContentSection = "learn" | "interviews" | "conferences" | "blog" | "tracks";

/** -------------------- Generic Content -------------------- */

export type ContentMeta = {
  slug: string;
  title: string;
  type: "lesson" | "post";
  section: ContentSection;
  access: Access;
  tags?: string[];
  description?: string;
  date?: string;
};

/**
 * Returns absolute path to a section directory
 * Example: src/content/learn
 */
function getDir(section: ContentSection) {
  return path.join(process.cwd(), "src", "content", section);
}

/**
 * Finds an MDX or MD file for a given slug.
 * IMPORTANT: slug can include subpaths like "60-day-cpp-interview/abi-object-layout"
 */
function findFilePath(section: ContentSection, slug: string) {
  const dir = getDir(section);

  const mdxPath = path.join(dir, `${slug}.mdx`);
  if (fs.existsSync(mdxPath)) return mdxPath;

  const mdPath = path.join(dir, `${slug}.md`);
  if (fs.existsSync(mdPath)) return mdPath;

  return null;
}

/**
 * Recursively list all .mdx/.md files under a directory.
 * Returns slugs relative to section dir, including subfolders.
 */
function listFilesRecursive(rootDir: string, currentDir = rootDir): string[] {
  if (!fs.existsSync(currentDir)) return [];
  const entries = fs.readdirSync(currentDir, { withFileTypes: true });

  const out: string[] = [];
  for (const e of entries) {
    const full = path.join(currentDir, e.name);
    if (e.isDirectory()) {
      out.push(...listFilesRecursive(rootDir, full));
      continue;
    }
    if (e.isFile() && (e.name.endsWith(".mdx") || e.name.endsWith(".md"))) {
      const rel = path.relative(rootDir, full); // e.g. "track/lesson.mdx"
      out.push(rel);
    }
  }
  return out;
}

/**
 * Returns list of content metadata for a section
 * Used by index pages like /learn, /blog, etc.
 * Supports nested folders (e.g. learn/<trackSlug>/<lessonSlug>.mdx)
 */
export function listContent(section: ContentSection): ContentMeta[] {
  const dir = getDir(section);
  if (!fs.existsSync(dir)) return [];

  const filesRel = listFilesRecursive(dir).filter(
    (f) => f.endsWith(".mdx") || f.endsWith(".md")
  );

  const items = filesRel.map((relFile) => {
    const slug = relFile.replace(/\.(mdx|md)$/, "").replaceAll("\\", "/"); // windows safe
    const fullPath = path.join(dir, relFile);
    const raw = fs.readFileSync(fullPath, "utf8");
    const { data } = matter(raw);

    return {
      slug,
      title: String(data.title ?? slug),
      type: (data.type ?? "post") as "lesson" | "post",
      section,
      access: (data.access ?? "free") as Access,
      tags: Array.isArray(data.tags) ? data.tags.map(String) : [],
      description: data.description ? String(data.description) : undefined,
      date: data.date ? String(data.date) : undefined,
    } satisfies ContentMeta;
  });

  // Sort newest first (if date exists)
  items.sort((a, b) => {
    if (!a.date || !b.date) return 0;
    return a.date < b.date ? 1 : -1;
  });

  return items;
}

/**
 * Loads full content (meta + body) by slug
 */
export function getContentBySlug(section: ContentSection, slug: string) {
  const filePath = findFilePath(section, slug);
  if (!filePath) return null;

  const raw = fs.readFileSync(filePath, "utf8");
  const { data, content } = matter(raw);

  const meta: ContentMeta = {
    slug,
    title: String(data.title ?? slug),
    type: (data.type ?? "post") as "lesson" | "post",
    section,
    access: (data.access ?? "free") as Access,
    tags: Array.isArray(data.tags) ? data.tags.map(String) : [],
    description: data.description ? String(data.description) : undefined,
    date: data.date ? String(data.date) : undefined,
  };

  return { meta, content };
}

/**
 * Same as getContentBySlug, but throws 404 if missing
 * Used by dynamic routes
 */
export function requireContent(section: ContentSection, slug: string) {
  const item = getContentBySlug(section, slug);

  console.log("LOOKING FOR:", {
    section,
    slug,
    path: path.join(process.cwd(), "src", "content", section, `${slug}.mdx`),
  });
  

  if (!item) {
    // Helpful debug output during development
    const dir = getDir(section);
    const files = fs.existsSync(dir) ? listFilesRecursive(dir) : [];
    console.error(
      `[cppvalley] Content not found ‚Üí section=${section}, slug=${slug}, files=[${files
        .slice(0, 60)
        .join(", ")}${files.length > 60 ? ", ..." : ""}]`
    );
    notFound();

    console.log("LOOKING FOR:", {
      section,
      slug,
      path: path.join(process.cwd(), "src", "content", section, `${slug}.mdx`),
    });
    
  }

  return item;
}

/** -------------------- Tracks -------------------- */

export type TrackMeta = {
  slug: string;
  title: string;
  access: Access;
  live: boolean;
  duration?: string;
  level?: string;
  description?: string;
  lessonCount?: number;
  tags?: string[];
  price?: number; // ‚úÖ NEW: per-track price (frontmatter: price: 1999)
};

// Item can be a leaf lesson OR a parent module with children
export type TrackSyllabusItem =
  | { title: string; slug: string; access: Access }
  | { title: string; access: Access; children: { title: string; slug: string; access: Access }[] };

export type TrackSection = {
  title: string;
  items: TrackSyllabusItem[];
};

function getTracksDir() {
  return path.join(process.cwd(), "src", "content", "tracks");
}

function parsePrice(raw: any): number | undefined {
  // Supports:
  // price: 1999
  // price: "1999"
  // price: "‚Çπ1,999"
  // price: "1999 INR"
  if (raw === undefined || raw === null || raw === "") return undefined;
  if (typeof raw === "number") return Number.isFinite(raw) ? raw : undefined;

  const s = String(raw).trim();
  const digits = s.replace(/[^\d.]/g, "");
  if (!digits) return undefined;

  const n = Number(digits);
  return Number.isFinite(n) ? n : undefined;
}

export function listTracks(): TrackMeta[] {
  const dir = getTracksDir();
  if (!fs.existsSync(dir)) return [];

  const files = fs.readdirSync(dir).filter((f) => f.endsWith(".mdx") || f.endsWith(".md"));

  const tracks = files.map((file) => {
    const raw = fs.readFileSync(path.join(dir, file), "utf8");
    const { data } = matter(raw);
    const slug = String(data.slug ?? file.replace(/\.(mdx|md)$/, ""));

    return {
      slug,
      title: String(data.title ?? slug),
      access: (data.access ?? "free") as Access,
      live: data.live !== false,
      duration: data.duration ? String(data.duration) : undefined,
      level: data.level ? String(data.level) : undefined,
      description: data.description ? String(data.description) : undefined,
      lessonCount: data.lessonCount ? Number(data.lessonCount) : undefined,
      tags: Array.isArray(data.tags) ? data.tags.map(String) : [],
      price: parsePrice((data as any).price), // ‚úÖ NEW
    } satisfies TrackMeta;
  });

  return tracks;
}

export function getTrackBySlug(trackSlug: string) {
  const dir = getTracksDir();
  const mdxPath = path.join(dir, `${trackSlug}.mdx`);
  const mdPath = path.join(dir, `${trackSlug}.md`);
  const filePath = fs.existsSync(mdxPath) ? mdxPath : fs.existsSync(mdPath) ? mdPath : null;
  if (!filePath) return null;

  const raw = fs.readFileSync(filePath, "utf8");
  const { data, content } = matter(raw);

  const meta: TrackMeta = {
    slug: String(data.slug ?? trackSlug),
    title: String(data.title ?? trackSlug),
    access: (data.access ?? "free") as Access,
    live: data.live !== false,
    duration: data.duration ? String(data.duration) : undefined,
    level: data.level ? String(data.level) : undefined,
    description: data.description ? String(data.description) : undefined,
    lessonCount: data.lessonCount ? Number(data.lessonCount) : undefined,
    tags: Array.isArray(data.tags) ? data.tags.map(String) : [],
    price: parsePrice((data as any).price), // ‚úÖ NEW
  };

  return { meta, content };
}

/**
 * Parses syllabus JSON blocks inside the track MDX.
 * Supports:
 * - leaf lesson: { title, slug, access }
 * - module with children: { title, access, children:[{title,slug,access}] }
 */
export function parseTrackSyllabus(trackContent: string): TrackSection[] {
  const lines = trackContent.split("\n");

  const sections: TrackSection[] = [];
  let current: TrackSection | null = null;

  let collecting = false;
  let jsonBuf: string[] = [];
  let braceBalance = 0;

  const countBraces = (s: string) => {
    let open = 0;
    let close = 0;
    for (const ch of s) {
      if (ch === "{") open++;
      else if (ch === "}") close++;
    }
    return open - close;
  };

  const flushJson = () => {
    if (!current) return;

    const raw = jsonBuf.join("\n").trim();
    jsonBuf = [];
    collecting = false;
    braceBalance = 0;

    try {
      const obj = JSON.parse(raw);

      // module with children
      if (Array.isArray(obj.children)) {
        current.items.push({
          title: String(obj.title ?? "Untitled"),
          access: (obj.access ?? "free") as Access,
          children: obj.children.map((c: any) => ({
            title: String(c.title ?? "Untitled"),
            slug: String(c.slug ?? ""),
            access: (c.access ?? "free") as Access,
          })),
        });
        return;
      }

      // single lesson
      if (obj.slug) {
        current.items.push({
          title: String(obj.title ?? obj.slug),
          slug: String(obj.slug),
          access: (obj.access ?? "free") as Access,
        });
      }
    } catch {
      // ignore malformed JSON blocks
    }
  };

  for (const line of lines) {
    const trimmed = line.trim();

    // headings: support ## and ###, but ignore "Syllabus"
    const heading = trimmed.match(/^#{2,3}\s+(.*)\s*$/);
    if (heading) {
      const title = heading[1].trim();
      if (title.toLowerCase() === "syllabus") continue;

      if (collecting) flushJson();

      current = { title, items: [] };
      sections.push(current);
      continue;
    }

    // start JSON bullet block
    if (!collecting && trimmed.startsWith("- {")) {
      if (!current) continue;

      collecting = true;
      const first = trimmed.replace(/^- /, ""); // remove "- "
      jsonBuf.push(first);
      braceBalance += countBraces(first);

      if (braceBalance === 0) flushJson();
      continue;
    }

    // keep collecting until braces balance to 0
    if (collecting) {
      jsonBuf.push(trimmed);
      braceBalance += countBraces(trimmed);
      if (braceBalance === 0) flushJson();
    }
  }

  if (collecting) flushJson();
  return sections;
}

export function flattenTrackLessonSlugs(sections: TrackSection[]): string[] {
  const slugs: string[] = [];

  for (const sec of sections) {
    for (const it of sec.items as any[]) {
      if (it && Array.isArray(it.children)) {
        for (const child of it.children) {
          if (child?.slug) slugs.push(child.slug);
        }
      } else if (it?.slug) {
        slugs.push(it.slug);
      }
    }
  }

  return Array.from(new Set(slugs));
}

=== FILE: src/lib/entitlements.ts ===
import { prisma } from "@/lib/prisma";
import { authOptions } from "@/auth";
import { getServerSession } from "next-auth";

export type UserEntitlements = {
  hasSitePremium: boolean;
  trackSlugs: string[];
};

export async function getUserEntitlements(): Promise<UserEntitlements> {
  try {
    const session = await getServerSession(authOptions);
    const email = session?.user?.email;
    if (!email) return { hasSitePremium: false, trackSlugs: [] };

    const user = await prisma.user.findUnique({
      where: { email },
      include: { entitlements: true },
    });

    if (!user) return { hasSitePremium: false, trackSlugs: [] };

    const active = (user.entitlements ?? []).filter((e) => e.status === "active");

    const hasSitePremium = active.some((e) => e.scope === "site");
    const trackSlugs = active
      .filter((e) => e.scope === "track" && e.trackSlug)
      .map((e) => e.trackSlug as string);

    return { hasSitePremium, trackSlugs };
  } catch {
    return { hasSitePremium: false, trackSlugs: [] };
  }
}

export function canAccessTrack(ent: UserEntitlements, trackSlug: string): boolean {
  if (ent?.hasSitePremium) return true;
  return Array.isArray(ent?.trackSlugs) && ent.trackSlugs.includes(trackSlug);
}

=== FILE: src/lib/razorpayPlans.ts ===
export type PlanKey = "monthly" | "yearly";

export const trackPlanIds: Record<string, Record<PlanKey, string>> = {
  "60-day-cpp-interview": {
    monthly: "plan_XXXXXXXXXXXXXX",
    yearly: "plan_YYYYYYYYYYYYYY",
  },
  // Add more tracks here
};

export const sitePlanIds: Record<PlanKey, string> = {
  monthly: "plan_SITE_MONTHLY",
  yearly: "plan_SITE_YEARLY",
};

=== FILE: src/auth.ts ===
import Google from "next-auth/providers/google";
import type { NextAuthOptions } from "next-auth";
import { PrismaAdapter } from "@auth/prisma-adapter";
import { prisma } from "@/lib/prisma";

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    Google({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  session: { strategy: "database" },
};

